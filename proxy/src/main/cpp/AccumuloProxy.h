/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AccumuloProxy_H
#define AccumuloProxy_H

#include <thrift/TDispatchProcessor.h>
#include "proxy_types.h"

namespace accumulo {

class AccumuloProxyIf {
 public:
  virtual ~AccumuloProxyIf() {}
  virtual void login(std::string& _return, const std::string& principal, const std::map<std::string, std::string> & loginProperties) = 0;
  virtual int32_t addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName) = 0;
  virtual void addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits) = 0;
  virtual void attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes) = 0;
  virtual void checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes) = 0;
  virtual void clearLocatorCache(const std::string& login, const std::string& tableName) = 0;
  virtual void cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude) = 0;
  virtual void compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait) = 0;
  virtual void cancelCompaction(const std::string& login, const std::string& tableName) = 0;
  virtual void createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type) = 0;
  virtual void deleteTable(const std::string& login, const std::string& tableName) = 0;
  virtual void deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow) = 0;
  virtual void exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir) = 0;
  virtual void flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait) = 0;
  virtual void getDiskUsage(std::vector<DiskUsage> & _return, const std::string& login, const std::set<std::string> & tables) = 0;
  virtual void getLocalityGroups(std::map<std::string, std::set<std::string> > & _return, const std::string& login, const std::string& tableName) = 0;
  virtual void getIteratorSetting(IteratorSetting& _return, const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope) = 0;
  virtual void getMaxRow(std::string& _return, const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive) = 0;
  virtual void getTableProperties(std::map<std::string, std::string> & _return, const std::string& login, const std::string& tableName) = 0;
  virtual void importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime) = 0;
  virtual void importTable(const std::string& login, const std::string& tableName, const std::string& importDir) = 0;
  virtual void listSplits(std::vector<std::string> & _return, const std::string& login, const std::string& tableName, const int32_t maxSplits) = 0;
  virtual void listTables(std::set<std::string> & _return, const std::string& login) = 0;
  virtual void listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return, const std::string& login, const std::string& tableName) = 0;
  virtual void listConstraints(std::map<std::string, int32_t> & _return, const std::string& login, const std::string& tableName) = 0;
  virtual void mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow) = 0;
  virtual void offlineTable(const std::string& login, const std::string& tableName, const bool wait) = 0;
  virtual void onlineTable(const std::string& login, const std::string& tableName, const bool wait) = 0;
  virtual void removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint) = 0;
  virtual void removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes) = 0;
  virtual void removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property) = 0;
  virtual void renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName) = 0;
  virtual void setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups) = 0;
  virtual void setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value) = 0;
  virtual void splitRangeByTablets(std::set<Range> & _return, const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits) = 0;
  virtual bool tableExists(const std::string& login, const std::string& tableName) = 0;
  virtual void tableIdMap(std::map<std::string, std::string> & _return, const std::string& login) = 0;
  virtual bool testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName) = 0;
  virtual void pingTabletServer(const std::string& login, const std::string& tserver) = 0;
  virtual void getActiveScans(std::vector<ActiveScan> & _return, const std::string& login, const std::string& tserver) = 0;
  virtual void getActiveCompactions(std::vector<ActiveCompaction> & _return, const std::string& login, const std::string& tserver) = 0;
  virtual void getSiteConfiguration(std::map<std::string, std::string> & _return, const std::string& login) = 0;
  virtual void getSystemConfiguration(std::map<std::string, std::string> & _return, const std::string& login) = 0;
  virtual void getTabletServers(std::vector<std::string> & _return, const std::string& login) = 0;
  virtual void removeProperty(const std::string& login, const std::string& property) = 0;
  virtual void setProperty(const std::string& login, const std::string& property, const std::string& value) = 0;
  virtual bool testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName) = 0;
  virtual bool authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties) = 0;
  virtual void changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations) = 0;
  virtual void changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password) = 0;
  virtual void createLocalUser(const std::string& login, const std::string& user, const std::string& password) = 0;
  virtual void dropLocalUser(const std::string& login, const std::string& user) = 0;
  virtual void getUserAuthorizations(std::vector<std::string> & _return, const std::string& login, const std::string& user) = 0;
  virtual void grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) = 0;
  virtual void grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) = 0;
  virtual bool hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) = 0;
  virtual bool hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) = 0;
  virtual void listLocalUsers(std::set<std::string> & _return, const std::string& login) = 0;
  virtual void revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) = 0;
  virtual void revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) = 0;
  virtual void createBatchScanner(std::string& _return, const std::string& login, const std::string& tableName, const BatchScanOptions& options) = 0;
  virtual void createScanner(std::string& _return, const std::string& login, const std::string& tableName, const ScanOptions& options) = 0;
  virtual bool hasNext(const std::string& scanner) = 0;
  virtual void nextEntry(KeyValueAndPeek& _return, const std::string& scanner) = 0;
  virtual void nextK(ScanResult& _return, const std::string& scanner, const int32_t k) = 0;
  virtual void closeScanner(const std::string& scanner) = 0;
  virtual void updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells) = 0;
  virtual void createWriter(std::string& _return, const std::string& login, const std::string& tableName, const WriterOptions& opts) = 0;
  virtual void update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells) = 0;
  virtual void flush(const std::string& writer) = 0;
  virtual void closeWriter(const std::string& writer) = 0;
  virtual ConditionalStatus::type updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates) = 0;
  virtual void createConditionalWriter(std::string& _return, const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options) = 0;
  virtual void updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return, const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates) = 0;
  virtual void closeConditionalWriter(const std::string& conditionalWriter) = 0;
  virtual void getRowRange(Range& _return, const std::string& row) = 0;
  virtual void getFollowing(Key& _return, const Key& key, const PartialKey::type part) = 0;
};

class AccumuloProxyIfFactory {
 public:
  typedef AccumuloProxyIf Handler;

  virtual ~AccumuloProxyIfFactory() {}

  virtual AccumuloProxyIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(AccumuloProxyIf* /* handler */) = 0;
};

class AccumuloProxyIfSingletonFactory : virtual public AccumuloProxyIfFactory {
 public:
  AccumuloProxyIfSingletonFactory(const boost::shared_ptr<AccumuloProxyIf>& iface) : iface_(iface) {}
  virtual ~AccumuloProxyIfSingletonFactory() {}

  virtual AccumuloProxyIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(AccumuloProxyIf* /* handler */) {}

 protected:
  boost::shared_ptr<AccumuloProxyIf> iface_;
};

class AccumuloProxyNull : virtual public AccumuloProxyIf {
 public:
  virtual ~AccumuloProxyNull() {}
  void login(std::string& /* _return */, const std::string& /* principal */, const std::map<std::string, std::string> & /* loginProperties */) {
    return;
  }
  int32_t addConstraint(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* constraintClassName */) {
    int32_t _return = 0;
    return _return;
  }
  void addSplits(const std::string& /* login */, const std::string& /* tableName */, const std::set<std::string> & /* splits */) {
    return;
  }
  void attachIterator(const std::string& /* login */, const std::string& /* tableName */, const IteratorSetting& /* setting */, const std::set<IteratorScope::type> & /* scopes */) {
    return;
  }
  void checkIteratorConflicts(const std::string& /* login */, const std::string& /* tableName */, const IteratorSetting& /* setting */, const std::set<IteratorScope::type> & /* scopes */) {
    return;
  }
  void clearLocatorCache(const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void cloneTable(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* newTableName */, const bool /* flush */, const std::map<std::string, std::string> & /* propertiesToSet */, const std::set<std::string> & /* propertiesToExclude */) {
    return;
  }
  void compactTable(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* startRow */, const std::string& /* endRow */, const std::vector<IteratorSetting> & /* iterators */, const bool /* flush */, const bool /* wait */) {
    return;
  }
  void cancelCompaction(const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void createTable(const std::string& /* login */, const std::string& /* tableName */, const bool /* versioningIter */, const TimeType::type /* type */) {
    return;
  }
  void deleteTable(const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void deleteRows(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* startRow */, const std::string& /* endRow */) {
    return;
  }
  void exportTable(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* exportDir */) {
    return;
  }
  void flushTable(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* startRow */, const std::string& /* endRow */, const bool /* wait */) {
    return;
  }
  void getDiskUsage(std::vector<DiskUsage> & /* _return */, const std::string& /* login */, const std::set<std::string> & /* tables */) {
    return;
  }
  void getLocalityGroups(std::map<std::string, std::set<std::string> > & /* _return */, const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void getIteratorSetting(IteratorSetting& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const std::string& /* iteratorName */, const IteratorScope::type /* scope */) {
    return;
  }
  void getMaxRow(std::string& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const std::set<std::string> & /* auths */, const std::string& /* startRow */, const bool /* startInclusive */, const std::string& /* endRow */, const bool /* endInclusive */) {
    return;
  }
  void getTableProperties(std::map<std::string, std::string> & /* _return */, const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void importDirectory(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* importDir */, const std::string& /* failureDir */, const bool /* setTime */) {
    return;
  }
  void importTable(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* importDir */) {
    return;
  }
  void listSplits(std::vector<std::string> & /* _return */, const std::string& /* login */, const std::string& /* tableName */, const int32_t /* maxSplits */) {
    return;
  }
  void listTables(std::set<std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  void listIterators(std::map<std::string, std::set<IteratorScope::type> > & /* _return */, const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void listConstraints(std::map<std::string, int32_t> & /* _return */, const std::string& /* login */, const std::string& /* tableName */) {
    return;
  }
  void mergeTablets(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* startRow */, const std::string& /* endRow */) {
    return;
  }
  void offlineTable(const std::string& /* login */, const std::string& /* tableName */, const bool /* wait */) {
    return;
  }
  void onlineTable(const std::string& /* login */, const std::string& /* tableName */, const bool /* wait */) {
    return;
  }
  void removeConstraint(const std::string& /* login */, const std::string& /* tableName */, const int32_t /* constraint */) {
    return;
  }
  void removeIterator(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* iterName */, const std::set<IteratorScope::type> & /* scopes */) {
    return;
  }
  void removeTableProperty(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* property */) {
    return;
  }
  void renameTable(const std::string& /* login */, const std::string& /* oldTableName */, const std::string& /* newTableName */) {
    return;
  }
  void setLocalityGroups(const std::string& /* login */, const std::string& /* tableName */, const std::map<std::string, std::set<std::string> > & /* groups */) {
    return;
  }
  void setTableProperty(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* property */, const std::string& /* value */) {
    return;
  }
  void splitRangeByTablets(std::set<Range> & /* _return */, const std::string& /* login */, const std::string& /* tableName */, const Range& /* range */, const int32_t /* maxSplits */) {
    return;
  }
  bool tableExists(const std::string& /* login */, const std::string& /* tableName */) {
    bool _return = false;
    return _return;
  }
  void tableIdMap(std::map<std::string, std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  bool testTableClassLoad(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* className */, const std::string& /* asTypeName */) {
    bool _return = false;
    return _return;
  }
  void pingTabletServer(const std::string& /* login */, const std::string& /* tserver */) {
    return;
  }
  void getActiveScans(std::vector<ActiveScan> & /* _return */, const std::string& /* login */, const std::string& /* tserver */) {
    return;
  }
  void getActiveCompactions(std::vector<ActiveCompaction> & /* _return */, const std::string& /* login */, const std::string& /* tserver */) {
    return;
  }
  void getSiteConfiguration(std::map<std::string, std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  void getSystemConfiguration(std::map<std::string, std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  void getTabletServers(std::vector<std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  void removeProperty(const std::string& /* login */, const std::string& /* property */) {
    return;
  }
  void setProperty(const std::string& /* login */, const std::string& /* property */, const std::string& /* value */) {
    return;
  }
  bool testClassLoad(const std::string& /* login */, const std::string& /* className */, const std::string& /* asTypeName */) {
    bool _return = false;
    return _return;
  }
  bool authenticateUser(const std::string& /* login */, const std::string& /* user */, const std::map<std::string, std::string> & /* properties */) {
    bool _return = false;
    return _return;
  }
  void changeUserAuthorizations(const std::string& /* login */, const std::string& /* user */, const std::set<std::string> & /* authorizations */) {
    return;
  }
  void changeLocalUserPassword(const std::string& /* login */, const std::string& /* user */, const std::string& /* password */) {
    return;
  }
  void createLocalUser(const std::string& /* login */, const std::string& /* user */, const std::string& /* password */) {
    return;
  }
  void dropLocalUser(const std::string& /* login */, const std::string& /* user */) {
    return;
  }
  void getUserAuthorizations(std::vector<std::string> & /* _return */, const std::string& /* login */, const std::string& /* user */) {
    return;
  }
  void grantSystemPermission(const std::string& /* login */, const std::string& /* user */, const SystemPermission::type /* perm */) {
    return;
  }
  void grantTablePermission(const std::string& /* login */, const std::string& /* user */, const std::string& /* table */, const TablePermission::type /* perm */) {
    return;
  }
  bool hasSystemPermission(const std::string& /* login */, const std::string& /* user */, const SystemPermission::type /* perm */) {
    bool _return = false;
    return _return;
  }
  bool hasTablePermission(const std::string& /* login */, const std::string& /* user */, const std::string& /* table */, const TablePermission::type /* perm */) {
    bool _return = false;
    return _return;
  }
  void listLocalUsers(std::set<std::string> & /* _return */, const std::string& /* login */) {
    return;
  }
  void revokeSystemPermission(const std::string& /* login */, const std::string& /* user */, const SystemPermission::type /* perm */) {
    return;
  }
  void revokeTablePermission(const std::string& /* login */, const std::string& /* user */, const std::string& /* table */, const TablePermission::type /* perm */) {
    return;
  }
  void createBatchScanner(std::string& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const BatchScanOptions& /* options */) {
    return;
  }
  void createScanner(std::string& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const ScanOptions& /* options */) {
    return;
  }
  bool hasNext(const std::string& /* scanner */) {
    bool _return = false;
    return _return;
  }
  void nextEntry(KeyValueAndPeek& /* _return */, const std::string& /* scanner */) {
    return;
  }
  void nextK(ScanResult& /* _return */, const std::string& /* scanner */, const int32_t /* k */) {
    return;
  }
  void closeScanner(const std::string& /* scanner */) {
    return;
  }
  void updateAndFlush(const std::string& /* login */, const std::string& /* tableName */, const std::map<std::string, std::vector<ColumnUpdate> > & /* cells */) {
    return;
  }
  void createWriter(std::string& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const WriterOptions& /* opts */) {
    return;
  }
  void update(const std::string& /* writer */, const std::map<std::string, std::vector<ColumnUpdate> > & /* cells */) {
    return;
  }
  void flush(const std::string& /* writer */) {
    return;
  }
  void closeWriter(const std::string& /* writer */) {
    return;
  }
  ConditionalStatus::type updateRowConditionally(const std::string& /* login */, const std::string& /* tableName */, const std::string& /* row */, const ConditionalUpdates& /* updates */) {
    ConditionalStatus::type _return = (ConditionalStatus::type)0;
    return _return;
  }
  void createConditionalWriter(std::string& /* _return */, const std::string& /* login */, const std::string& /* tableName */, const ConditionalWriterOptions& /* options */) {
    return;
  }
  void updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & /* _return */, const std::string& /* conditionalWriter */, const std::map<std::string, ConditionalUpdates> & /* updates */) {
    return;
  }
  void closeConditionalWriter(const std::string& /* conditionalWriter */) {
    return;
  }
  void getRowRange(Range& /* _return */, const std::string& /* row */) {
    return;
  }
  void getFollowing(Key& /* _return */, const Key& /* key */, const PartialKey::type /* part */) {
    return;
  }
};

typedef struct _AccumuloProxy_login_args__isset {
  _AccumuloProxy_login_args__isset() : principal(false), loginProperties(false) {}
  bool principal;
  bool loginProperties;
} _AccumuloProxy_login_args__isset;

class AccumuloProxy_login_args {
 public:

  AccumuloProxy_login_args() : principal() {
  }

  virtual ~AccumuloProxy_login_args() throw() {}

  std::string principal;
  std::map<std::string, std::string>  loginProperties;

  _AccumuloProxy_login_args__isset __isset;

  void __set_principal(const std::string& val) {
    principal = val;
  }

  void __set_loginProperties(const std::map<std::string, std::string> & val) {
    loginProperties = val;
  }

  bool operator == (const AccumuloProxy_login_args & rhs) const
  {
    if (!(principal == rhs.principal))
      return false;
    if (!(loginProperties == rhs.loginProperties))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_login_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_login_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_login_pargs {
 public:


  virtual ~AccumuloProxy_login_pargs() throw() {}

  const std::string* principal;
  const std::map<std::string, std::string> * loginProperties;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_login_result__isset {
  _AccumuloProxy_login_result__isset() : success(false), ouch2(false) {}
  bool success;
  bool ouch2;
} _AccumuloProxy_login_result__isset;

class AccumuloProxy_login_result {
 public:

  AccumuloProxy_login_result() : success() {
  }

  virtual ~AccumuloProxy_login_result() throw() {}

  std::string success;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_login_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_login_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_login_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_login_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_login_presult__isset {
  _AccumuloProxy_login_presult__isset() : success(false), ouch2(false) {}
  bool success;
  bool ouch2;
} _AccumuloProxy_login_presult__isset;

class AccumuloProxy_login_presult {
 public:


  virtual ~AccumuloProxy_login_presult() throw() {}

  std::string* success;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_login_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_addConstraint_args__isset {
  _AccumuloProxy_addConstraint_args__isset() : login(false), tableName(false), constraintClassName(false) {}
  bool login;
  bool tableName;
  bool constraintClassName;
} _AccumuloProxy_addConstraint_args__isset;

class AccumuloProxy_addConstraint_args {
 public:

  AccumuloProxy_addConstraint_args() : login(), tableName(), constraintClassName() {
  }

  virtual ~AccumuloProxy_addConstraint_args() throw() {}

  std::string login;
  std::string tableName;
  std::string constraintClassName;

  _AccumuloProxy_addConstraint_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_constraintClassName(const std::string& val) {
    constraintClassName = val;
  }

  bool operator == (const AccumuloProxy_addConstraint_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(constraintClassName == rhs.constraintClassName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_addConstraint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_addConstraint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_addConstraint_pargs {
 public:


  virtual ~AccumuloProxy_addConstraint_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* constraintClassName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_addConstraint_result__isset {
  _AccumuloProxy_addConstraint_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_addConstraint_result__isset;

class AccumuloProxy_addConstraint_result {
 public:

  AccumuloProxy_addConstraint_result() : success(0) {
  }

  virtual ~AccumuloProxy_addConstraint_result() throw() {}

  int32_t success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_addConstraint_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_addConstraint_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_addConstraint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_addConstraint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_addConstraint_presult__isset {
  _AccumuloProxy_addConstraint_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_addConstraint_presult__isset;

class AccumuloProxy_addConstraint_presult {
 public:


  virtual ~AccumuloProxy_addConstraint_presult() throw() {}

  int32_t* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_addConstraint_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_addSplits_args__isset {
  _AccumuloProxy_addSplits_args__isset() : login(false), tableName(false), splits(false) {}
  bool login;
  bool tableName;
  bool splits;
} _AccumuloProxy_addSplits_args__isset;

class AccumuloProxy_addSplits_args {
 public:

  AccumuloProxy_addSplits_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_addSplits_args() throw() {}

  std::string login;
  std::string tableName;
  std::set<std::string>  splits;

  _AccumuloProxy_addSplits_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_splits(const std::set<std::string> & val) {
    splits = val;
  }

  bool operator == (const AccumuloProxy_addSplits_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(splits == rhs.splits))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_addSplits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_addSplits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_addSplits_pargs {
 public:


  virtual ~AccumuloProxy_addSplits_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::set<std::string> * splits;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_addSplits_result__isset {
  _AccumuloProxy_addSplits_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_addSplits_result__isset;

class AccumuloProxy_addSplits_result {
 public:

  AccumuloProxy_addSplits_result() {
  }

  virtual ~AccumuloProxy_addSplits_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_addSplits_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_addSplits_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_addSplits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_addSplits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_addSplits_presult__isset {
  _AccumuloProxy_addSplits_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_addSplits_presult__isset;

class AccumuloProxy_addSplits_presult {
 public:


  virtual ~AccumuloProxy_addSplits_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_addSplits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_attachIterator_args__isset {
  _AccumuloProxy_attachIterator_args__isset() : login(false), tableName(false), setting(false), scopes(false) {}
  bool login;
  bool tableName;
  bool setting;
  bool scopes;
} _AccumuloProxy_attachIterator_args__isset;

class AccumuloProxy_attachIterator_args {
 public:

  AccumuloProxy_attachIterator_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_attachIterator_args() throw() {}

  std::string login;
  std::string tableName;
  IteratorSetting setting;
  std::set<IteratorScope::type>  scopes;

  _AccumuloProxy_attachIterator_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_setting(const IteratorSetting& val) {
    setting = val;
  }

  void __set_scopes(const std::set<IteratorScope::type> & val) {
    scopes = val;
  }

  bool operator == (const AccumuloProxy_attachIterator_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(setting == rhs.setting))
      return false;
    if (!(scopes == rhs.scopes))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_attachIterator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_attachIterator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_attachIterator_pargs {
 public:


  virtual ~AccumuloProxy_attachIterator_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const IteratorSetting* setting;
  const std::set<IteratorScope::type> * scopes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_attachIterator_result__isset {
  _AccumuloProxy_attachIterator_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_attachIterator_result__isset;

class AccumuloProxy_attachIterator_result {
 public:

  AccumuloProxy_attachIterator_result() {
  }

  virtual ~AccumuloProxy_attachIterator_result() throw() {}

  AccumuloSecurityException ouch1;
  AccumuloException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_attachIterator_result__isset __isset;

  void __set_ouch1(const AccumuloSecurityException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_attachIterator_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_attachIterator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_attachIterator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_attachIterator_presult__isset {
  _AccumuloProxy_attachIterator_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_attachIterator_presult__isset;

class AccumuloProxy_attachIterator_presult {
 public:


  virtual ~AccumuloProxy_attachIterator_presult() throw() {}

  AccumuloSecurityException ouch1;
  AccumuloException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_attachIterator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_checkIteratorConflicts_args__isset {
  _AccumuloProxy_checkIteratorConflicts_args__isset() : login(false), tableName(false), setting(false), scopes(false) {}
  bool login;
  bool tableName;
  bool setting;
  bool scopes;
} _AccumuloProxy_checkIteratorConflicts_args__isset;

class AccumuloProxy_checkIteratorConflicts_args {
 public:

  AccumuloProxy_checkIteratorConflicts_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_checkIteratorConflicts_args() throw() {}

  std::string login;
  std::string tableName;
  IteratorSetting setting;
  std::set<IteratorScope::type>  scopes;

  _AccumuloProxy_checkIteratorConflicts_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_setting(const IteratorSetting& val) {
    setting = val;
  }

  void __set_scopes(const std::set<IteratorScope::type> & val) {
    scopes = val;
  }

  bool operator == (const AccumuloProxy_checkIteratorConflicts_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(setting == rhs.setting))
      return false;
    if (!(scopes == rhs.scopes))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_checkIteratorConflicts_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_checkIteratorConflicts_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_checkIteratorConflicts_pargs {
 public:


  virtual ~AccumuloProxy_checkIteratorConflicts_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const IteratorSetting* setting;
  const std::set<IteratorScope::type> * scopes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_checkIteratorConflicts_result__isset {
  _AccumuloProxy_checkIteratorConflicts_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_checkIteratorConflicts_result__isset;

class AccumuloProxy_checkIteratorConflicts_result {
 public:

  AccumuloProxy_checkIteratorConflicts_result() {
  }

  virtual ~AccumuloProxy_checkIteratorConflicts_result() throw() {}

  AccumuloSecurityException ouch1;
  AccumuloException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_checkIteratorConflicts_result__isset __isset;

  void __set_ouch1(const AccumuloSecurityException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_checkIteratorConflicts_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_checkIteratorConflicts_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_checkIteratorConflicts_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_checkIteratorConflicts_presult__isset {
  _AccumuloProxy_checkIteratorConflicts_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_checkIteratorConflicts_presult__isset;

class AccumuloProxy_checkIteratorConflicts_presult {
 public:


  virtual ~AccumuloProxy_checkIteratorConflicts_presult() throw() {}

  AccumuloSecurityException ouch1;
  AccumuloException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_checkIteratorConflicts_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_clearLocatorCache_args__isset {
  _AccumuloProxy_clearLocatorCache_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_clearLocatorCache_args__isset;

class AccumuloProxy_clearLocatorCache_args {
 public:

  AccumuloProxy_clearLocatorCache_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_clearLocatorCache_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_clearLocatorCache_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_clearLocatorCache_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_clearLocatorCache_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_clearLocatorCache_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_clearLocatorCache_pargs {
 public:


  virtual ~AccumuloProxy_clearLocatorCache_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_clearLocatorCache_result__isset {
  _AccumuloProxy_clearLocatorCache_result__isset() : ouch1(false) {}
  bool ouch1;
} _AccumuloProxy_clearLocatorCache_result__isset;

class AccumuloProxy_clearLocatorCache_result {
 public:

  AccumuloProxy_clearLocatorCache_result() {
  }

  virtual ~AccumuloProxy_clearLocatorCache_result() throw() {}

  TableNotFoundException ouch1;

  _AccumuloProxy_clearLocatorCache_result__isset __isset;

  void __set_ouch1(const TableNotFoundException& val) {
    ouch1 = val;
  }

  bool operator == (const AccumuloProxy_clearLocatorCache_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_clearLocatorCache_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_clearLocatorCache_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_clearLocatorCache_presult__isset {
  _AccumuloProxy_clearLocatorCache_presult__isset() : ouch1(false) {}
  bool ouch1;
} _AccumuloProxy_clearLocatorCache_presult__isset;

class AccumuloProxy_clearLocatorCache_presult {
 public:


  virtual ~AccumuloProxy_clearLocatorCache_presult() throw() {}

  TableNotFoundException ouch1;

  _AccumuloProxy_clearLocatorCache_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_cloneTable_args__isset {
  _AccumuloProxy_cloneTable_args__isset() : login(false), tableName(false), newTableName(false), flush(false), propertiesToSet(false), propertiesToExclude(false) {}
  bool login;
  bool tableName;
  bool newTableName;
  bool flush;
  bool propertiesToSet;
  bool propertiesToExclude;
} _AccumuloProxy_cloneTable_args__isset;

class AccumuloProxy_cloneTable_args {
 public:

  AccumuloProxy_cloneTable_args() : login(), tableName(), newTableName(), flush(0) {
  }

  virtual ~AccumuloProxy_cloneTable_args() throw() {}

  std::string login;
  std::string tableName;
  std::string newTableName;
  bool flush;
  std::map<std::string, std::string>  propertiesToSet;
  std::set<std::string>  propertiesToExclude;

  _AccumuloProxy_cloneTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_newTableName(const std::string& val) {
    newTableName = val;
  }

  void __set_flush(const bool val) {
    flush = val;
  }

  void __set_propertiesToSet(const std::map<std::string, std::string> & val) {
    propertiesToSet = val;
  }

  void __set_propertiesToExclude(const std::set<std::string> & val) {
    propertiesToExclude = val;
  }

  bool operator == (const AccumuloProxy_cloneTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(newTableName == rhs.newTableName))
      return false;
    if (!(flush == rhs.flush))
      return false;
    if (!(propertiesToSet == rhs.propertiesToSet))
      return false;
    if (!(propertiesToExclude == rhs.propertiesToExclude))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_cloneTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_cloneTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_cloneTable_pargs {
 public:


  virtual ~AccumuloProxy_cloneTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* newTableName;
  const bool* flush;
  const std::map<std::string, std::string> * propertiesToSet;
  const std::set<std::string> * propertiesToExclude;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_cloneTable_result__isset {
  _AccumuloProxy_cloneTable_result__isset() : ouch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_cloneTable_result__isset;

class AccumuloProxy_cloneTable_result {
 public:

  AccumuloProxy_cloneTable_result() {
  }

  virtual ~AccumuloProxy_cloneTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  TableExistsException ouch4;

  _AccumuloProxy_cloneTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  void __set_ouch4(const TableExistsException& val) {
    ouch4 = val;
  }

  bool operator == (const AccumuloProxy_cloneTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    if (!(ouch4 == rhs.ouch4))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_cloneTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_cloneTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_cloneTable_presult__isset {
  _AccumuloProxy_cloneTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_cloneTable_presult__isset;

class AccumuloProxy_cloneTable_presult {
 public:


  virtual ~AccumuloProxy_cloneTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  TableExistsException ouch4;

  _AccumuloProxy_cloneTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_compactTable_args__isset {
  _AccumuloProxy_compactTable_args__isset() : login(false), tableName(false), startRow(false), endRow(false), iterators(false), flush(false), wait(false) {}
  bool login;
  bool tableName;
  bool startRow;
  bool endRow;
  bool iterators;
  bool flush;
  bool wait;
} _AccumuloProxy_compactTable_args__isset;

class AccumuloProxy_compactTable_args {
 public:

  AccumuloProxy_compactTable_args() : login(), tableName(), startRow(), endRow(), flush(0), wait(0) {
  }

  virtual ~AccumuloProxy_compactTable_args() throw() {}

  std::string login;
  std::string tableName;
  std::string startRow;
  std::string endRow;
  std::vector<IteratorSetting>  iterators;
  bool flush;
  bool wait;

  _AccumuloProxy_compactTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_startRow(const std::string& val) {
    startRow = val;
  }

  void __set_endRow(const std::string& val) {
    endRow = val;
  }

  void __set_iterators(const std::vector<IteratorSetting> & val) {
    iterators = val;
  }

  void __set_flush(const bool val) {
    flush = val;
  }

  void __set_wait(const bool val) {
    wait = val;
  }

  bool operator == (const AccumuloProxy_compactTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    if (!(iterators == rhs.iterators))
      return false;
    if (!(flush == rhs.flush))
      return false;
    if (!(wait == rhs.wait))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_compactTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_compactTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_compactTable_pargs {
 public:


  virtual ~AccumuloProxy_compactTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* startRow;
  const std::string* endRow;
  const std::vector<IteratorSetting> * iterators;
  const bool* flush;
  const bool* wait;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_compactTable_result__isset {
  _AccumuloProxy_compactTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_compactTable_result__isset;

class AccumuloProxy_compactTable_result {
 public:

  AccumuloProxy_compactTable_result() {
  }

  virtual ~AccumuloProxy_compactTable_result() throw() {}

  AccumuloSecurityException ouch1;
  TableNotFoundException ouch2;
  AccumuloException ouch3;

  _AccumuloProxy_compactTable_result__isset __isset;

  void __set_ouch1(const AccumuloSecurityException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const TableNotFoundException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_compactTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_compactTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_compactTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_compactTable_presult__isset {
  _AccumuloProxy_compactTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_compactTable_presult__isset;

class AccumuloProxy_compactTable_presult {
 public:


  virtual ~AccumuloProxy_compactTable_presult() throw() {}

  AccumuloSecurityException ouch1;
  TableNotFoundException ouch2;
  AccumuloException ouch3;

  _AccumuloProxy_compactTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_cancelCompaction_args__isset {
  _AccumuloProxy_cancelCompaction_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_cancelCompaction_args__isset;

class AccumuloProxy_cancelCompaction_args {
 public:

  AccumuloProxy_cancelCompaction_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_cancelCompaction_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_cancelCompaction_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_cancelCompaction_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_cancelCompaction_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_cancelCompaction_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_cancelCompaction_pargs {
 public:


  virtual ~AccumuloProxy_cancelCompaction_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_cancelCompaction_result__isset {
  _AccumuloProxy_cancelCompaction_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_cancelCompaction_result__isset;

class AccumuloProxy_cancelCompaction_result {
 public:

  AccumuloProxy_cancelCompaction_result() {
  }

  virtual ~AccumuloProxy_cancelCompaction_result() throw() {}

  AccumuloSecurityException ouch1;
  TableNotFoundException ouch2;
  AccumuloException ouch3;

  _AccumuloProxy_cancelCompaction_result__isset __isset;

  void __set_ouch1(const AccumuloSecurityException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const TableNotFoundException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_cancelCompaction_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_cancelCompaction_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_cancelCompaction_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_cancelCompaction_presult__isset {
  _AccumuloProxy_cancelCompaction_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_cancelCompaction_presult__isset;

class AccumuloProxy_cancelCompaction_presult {
 public:


  virtual ~AccumuloProxy_cancelCompaction_presult() throw() {}

  AccumuloSecurityException ouch1;
  TableNotFoundException ouch2;
  AccumuloException ouch3;

  _AccumuloProxy_cancelCompaction_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createTable_args__isset {
  _AccumuloProxy_createTable_args__isset() : login(false), tableName(false), versioningIter(false), type(false) {}
  bool login;
  bool tableName;
  bool versioningIter;
  bool type;
} _AccumuloProxy_createTable_args__isset;

class AccumuloProxy_createTable_args {
 public:

  AccumuloProxy_createTable_args() : login(), tableName(), versioningIter(0), type((TimeType::type)0) {
  }

  virtual ~AccumuloProxy_createTable_args() throw() {}

  std::string login;
  std::string tableName;
  bool versioningIter;
  TimeType::type type;

  _AccumuloProxy_createTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_versioningIter(const bool val) {
    versioningIter = val;
  }

  void __set_type(const TimeType::type val) {
    type = val;
  }

  bool operator == (const AccumuloProxy_createTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(versioningIter == rhs.versioningIter))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createTable_pargs {
 public:


  virtual ~AccumuloProxy_createTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const bool* versioningIter;
  const TimeType::type* type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createTable_result__isset {
  _AccumuloProxy_createTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createTable_result__isset;

class AccumuloProxy_createTable_result {
 public:

  AccumuloProxy_createTable_result() {
  }

  virtual ~AccumuloProxy_createTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableExistsException ouch3;

  _AccumuloProxy_createTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableExistsException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_createTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createTable_presult__isset {
  _AccumuloProxy_createTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createTable_presult__isset;

class AccumuloProxy_createTable_presult {
 public:


  virtual ~AccumuloProxy_createTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableExistsException ouch3;

  _AccumuloProxy_createTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_deleteTable_args__isset {
  _AccumuloProxy_deleteTable_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_deleteTable_args__isset;

class AccumuloProxy_deleteTable_args {
 public:

  AccumuloProxy_deleteTable_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_deleteTable_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_deleteTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_deleteTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_deleteTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_deleteTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_deleteTable_pargs {
 public:


  virtual ~AccumuloProxy_deleteTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_deleteTable_result__isset {
  _AccumuloProxy_deleteTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_deleteTable_result__isset;

class AccumuloProxy_deleteTable_result {
 public:

  AccumuloProxy_deleteTable_result() {
  }

  virtual ~AccumuloProxy_deleteTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_deleteTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_deleteTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_deleteTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_deleteTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_deleteTable_presult__isset {
  _AccumuloProxy_deleteTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_deleteTable_presult__isset;

class AccumuloProxy_deleteTable_presult {
 public:


  virtual ~AccumuloProxy_deleteTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_deleteTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_deleteRows_args__isset {
  _AccumuloProxy_deleteRows_args__isset() : login(false), tableName(false), startRow(false), endRow(false) {}
  bool login;
  bool tableName;
  bool startRow;
  bool endRow;
} _AccumuloProxy_deleteRows_args__isset;

class AccumuloProxy_deleteRows_args {
 public:

  AccumuloProxy_deleteRows_args() : login(), tableName(), startRow(), endRow() {
  }

  virtual ~AccumuloProxy_deleteRows_args() throw() {}

  std::string login;
  std::string tableName;
  std::string startRow;
  std::string endRow;

  _AccumuloProxy_deleteRows_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_startRow(const std::string& val) {
    startRow = val;
  }

  void __set_endRow(const std::string& val) {
    endRow = val;
  }

  bool operator == (const AccumuloProxy_deleteRows_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_deleteRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_deleteRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_deleteRows_pargs {
 public:


  virtual ~AccumuloProxy_deleteRows_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* startRow;
  const std::string* endRow;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_deleteRows_result__isset {
  _AccumuloProxy_deleteRows_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_deleteRows_result__isset;

class AccumuloProxy_deleteRows_result {
 public:

  AccumuloProxy_deleteRows_result() {
  }

  virtual ~AccumuloProxy_deleteRows_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_deleteRows_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_deleteRows_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_deleteRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_deleteRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_deleteRows_presult__isset {
  _AccumuloProxy_deleteRows_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_deleteRows_presult__isset;

class AccumuloProxy_deleteRows_presult {
 public:


  virtual ~AccumuloProxy_deleteRows_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_deleteRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_exportTable_args__isset {
  _AccumuloProxy_exportTable_args__isset() : login(false), tableName(false), exportDir(false) {}
  bool login;
  bool tableName;
  bool exportDir;
} _AccumuloProxy_exportTable_args__isset;

class AccumuloProxy_exportTable_args {
 public:

  AccumuloProxy_exportTable_args() : login(), tableName(), exportDir() {
  }

  virtual ~AccumuloProxy_exportTable_args() throw() {}

  std::string login;
  std::string tableName;
  std::string exportDir;

  _AccumuloProxy_exportTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_exportDir(const std::string& val) {
    exportDir = val;
  }

  bool operator == (const AccumuloProxy_exportTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(exportDir == rhs.exportDir))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_exportTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_exportTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_exportTable_pargs {
 public:


  virtual ~AccumuloProxy_exportTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* exportDir;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_exportTable_result__isset {
  _AccumuloProxy_exportTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_exportTable_result__isset;

class AccumuloProxy_exportTable_result {
 public:

  AccumuloProxy_exportTable_result() {
  }

  virtual ~AccumuloProxy_exportTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_exportTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_exportTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_exportTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_exportTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_exportTable_presult__isset {
  _AccumuloProxy_exportTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_exportTable_presult__isset;

class AccumuloProxy_exportTable_presult {
 public:


  virtual ~AccumuloProxy_exportTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_exportTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_flushTable_args__isset {
  _AccumuloProxy_flushTable_args__isset() : login(false), tableName(false), startRow(false), endRow(false), wait(false) {}
  bool login;
  bool tableName;
  bool startRow;
  bool endRow;
  bool wait;
} _AccumuloProxy_flushTable_args__isset;

class AccumuloProxy_flushTable_args {
 public:

  AccumuloProxy_flushTable_args() : login(), tableName(), startRow(), endRow(), wait(0) {
  }

  virtual ~AccumuloProxy_flushTable_args() throw() {}

  std::string login;
  std::string tableName;
  std::string startRow;
  std::string endRow;
  bool wait;

  _AccumuloProxy_flushTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_startRow(const std::string& val) {
    startRow = val;
  }

  void __set_endRow(const std::string& val) {
    endRow = val;
  }

  void __set_wait(const bool val) {
    wait = val;
  }

  bool operator == (const AccumuloProxy_flushTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    if (!(wait == rhs.wait))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_flushTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_flushTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_flushTable_pargs {
 public:


  virtual ~AccumuloProxy_flushTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* startRow;
  const std::string* endRow;
  const bool* wait;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_flushTable_result__isset {
  _AccumuloProxy_flushTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_flushTable_result__isset;

class AccumuloProxy_flushTable_result {
 public:

  AccumuloProxy_flushTable_result() {
  }

  virtual ~AccumuloProxy_flushTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_flushTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_flushTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_flushTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_flushTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_flushTable_presult__isset {
  _AccumuloProxy_flushTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_flushTable_presult__isset;

class AccumuloProxy_flushTable_presult {
 public:


  virtual ~AccumuloProxy_flushTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_flushTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getDiskUsage_args__isset {
  _AccumuloProxy_getDiskUsage_args__isset() : login(false), tables(false) {}
  bool login;
  bool tables;
} _AccumuloProxy_getDiskUsage_args__isset;

class AccumuloProxy_getDiskUsage_args {
 public:

  AccumuloProxy_getDiskUsage_args() : login() {
  }

  virtual ~AccumuloProxy_getDiskUsage_args() throw() {}

  std::string login;
  std::set<std::string>  tables;

  _AccumuloProxy_getDiskUsage_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tables(const std::set<std::string> & val) {
    tables = val;
  }

  bool operator == (const AccumuloProxy_getDiskUsage_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tables == rhs.tables))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getDiskUsage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getDiskUsage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getDiskUsage_pargs {
 public:


  virtual ~AccumuloProxy_getDiskUsage_pargs() throw() {}

  const std::string* login;
  const std::set<std::string> * tables;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getDiskUsage_result__isset {
  _AccumuloProxy_getDiskUsage_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getDiskUsage_result__isset;

class AccumuloProxy_getDiskUsage_result {
 public:

  AccumuloProxy_getDiskUsage_result() {
  }

  virtual ~AccumuloProxy_getDiskUsage_result() throw() {}

  std::vector<DiskUsage>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getDiskUsage_result__isset __isset;

  void __set_success(const std::vector<DiskUsage> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_getDiskUsage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getDiskUsage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getDiskUsage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getDiskUsage_presult__isset {
  _AccumuloProxy_getDiskUsage_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getDiskUsage_presult__isset;

class AccumuloProxy_getDiskUsage_presult {
 public:


  virtual ~AccumuloProxy_getDiskUsage_presult() throw() {}

  std::vector<DiskUsage> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getDiskUsage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getLocalityGroups_args__isset {
  _AccumuloProxy_getLocalityGroups_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_getLocalityGroups_args__isset;

class AccumuloProxy_getLocalityGroups_args {
 public:

  AccumuloProxy_getLocalityGroups_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_getLocalityGroups_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_getLocalityGroups_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_getLocalityGroups_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getLocalityGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getLocalityGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getLocalityGroups_pargs {
 public:


  virtual ~AccumuloProxy_getLocalityGroups_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getLocalityGroups_result__isset {
  _AccumuloProxy_getLocalityGroups_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getLocalityGroups_result__isset;

class AccumuloProxy_getLocalityGroups_result {
 public:

  AccumuloProxy_getLocalityGroups_result() {
  }

  virtual ~AccumuloProxy_getLocalityGroups_result() throw() {}

  std::map<std::string, std::set<std::string> >  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getLocalityGroups_result__isset __isset;

  void __set_success(const std::map<std::string, std::set<std::string> > & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_getLocalityGroups_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getLocalityGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getLocalityGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getLocalityGroups_presult__isset {
  _AccumuloProxy_getLocalityGroups_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getLocalityGroups_presult__isset;

class AccumuloProxy_getLocalityGroups_presult {
 public:


  virtual ~AccumuloProxy_getLocalityGroups_presult() throw() {}

  std::map<std::string, std::set<std::string> > * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getLocalityGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getIteratorSetting_args__isset {
  _AccumuloProxy_getIteratorSetting_args__isset() : login(false), tableName(false), iteratorName(false), scope(false) {}
  bool login;
  bool tableName;
  bool iteratorName;
  bool scope;
} _AccumuloProxy_getIteratorSetting_args__isset;

class AccumuloProxy_getIteratorSetting_args {
 public:

  AccumuloProxy_getIteratorSetting_args() : login(), tableName(), iteratorName(), scope((IteratorScope::type)0) {
  }

  virtual ~AccumuloProxy_getIteratorSetting_args() throw() {}

  std::string login;
  std::string tableName;
  std::string iteratorName;
  IteratorScope::type scope;

  _AccumuloProxy_getIteratorSetting_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_iteratorName(const std::string& val) {
    iteratorName = val;
  }

  void __set_scope(const IteratorScope::type val) {
    scope = val;
  }

  bool operator == (const AccumuloProxy_getIteratorSetting_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(iteratorName == rhs.iteratorName))
      return false;
    if (!(scope == rhs.scope))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getIteratorSetting_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getIteratorSetting_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getIteratorSetting_pargs {
 public:


  virtual ~AccumuloProxy_getIteratorSetting_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* iteratorName;
  const IteratorScope::type* scope;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getIteratorSetting_result__isset {
  _AccumuloProxy_getIteratorSetting_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getIteratorSetting_result__isset;

class AccumuloProxy_getIteratorSetting_result {
 public:

  AccumuloProxy_getIteratorSetting_result() {
  }

  virtual ~AccumuloProxy_getIteratorSetting_result() throw() {}

  IteratorSetting success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getIteratorSetting_result__isset __isset;

  void __set_success(const IteratorSetting& val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_getIteratorSetting_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getIteratorSetting_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getIteratorSetting_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getIteratorSetting_presult__isset {
  _AccumuloProxy_getIteratorSetting_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getIteratorSetting_presult__isset;

class AccumuloProxy_getIteratorSetting_presult {
 public:


  virtual ~AccumuloProxy_getIteratorSetting_presult() throw() {}

  IteratorSetting* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getIteratorSetting_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getMaxRow_args__isset {
  _AccumuloProxy_getMaxRow_args__isset() : login(false), tableName(false), auths(false), startRow(false), startInclusive(false), endRow(false), endInclusive(false) {}
  bool login;
  bool tableName;
  bool auths;
  bool startRow;
  bool startInclusive;
  bool endRow;
  bool endInclusive;
} _AccumuloProxy_getMaxRow_args__isset;

class AccumuloProxy_getMaxRow_args {
 public:

  AccumuloProxy_getMaxRow_args() : login(), tableName(), startRow(), startInclusive(0), endRow(), endInclusive(0) {
  }

  virtual ~AccumuloProxy_getMaxRow_args() throw() {}

  std::string login;
  std::string tableName;
  std::set<std::string>  auths;
  std::string startRow;
  bool startInclusive;
  std::string endRow;
  bool endInclusive;

  _AccumuloProxy_getMaxRow_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_auths(const std::set<std::string> & val) {
    auths = val;
  }

  void __set_startRow(const std::string& val) {
    startRow = val;
  }

  void __set_startInclusive(const bool val) {
    startInclusive = val;
  }

  void __set_endRow(const std::string& val) {
    endRow = val;
  }

  void __set_endInclusive(const bool val) {
    endInclusive = val;
  }

  bool operator == (const AccumuloProxy_getMaxRow_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(auths == rhs.auths))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(startInclusive == rhs.startInclusive))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    if (!(endInclusive == rhs.endInclusive))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getMaxRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getMaxRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getMaxRow_pargs {
 public:


  virtual ~AccumuloProxy_getMaxRow_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::set<std::string> * auths;
  const std::string* startRow;
  const bool* startInclusive;
  const std::string* endRow;
  const bool* endInclusive;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getMaxRow_result__isset {
  _AccumuloProxy_getMaxRow_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getMaxRow_result__isset;

class AccumuloProxy_getMaxRow_result {
 public:

  AccumuloProxy_getMaxRow_result() : success() {
  }

  virtual ~AccumuloProxy_getMaxRow_result() throw() {}

  std::string success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getMaxRow_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_getMaxRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getMaxRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getMaxRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getMaxRow_presult__isset {
  _AccumuloProxy_getMaxRow_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getMaxRow_presult__isset;

class AccumuloProxy_getMaxRow_presult {
 public:


  virtual ~AccumuloProxy_getMaxRow_presult() throw() {}

  std::string* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getMaxRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getTableProperties_args__isset {
  _AccumuloProxy_getTableProperties_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_getTableProperties_args__isset;

class AccumuloProxy_getTableProperties_args {
 public:

  AccumuloProxy_getTableProperties_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_getTableProperties_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_getTableProperties_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_getTableProperties_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getTableProperties_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getTableProperties_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getTableProperties_pargs {
 public:


  virtual ~AccumuloProxy_getTableProperties_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getTableProperties_result__isset {
  _AccumuloProxy_getTableProperties_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getTableProperties_result__isset;

class AccumuloProxy_getTableProperties_result {
 public:

  AccumuloProxy_getTableProperties_result() {
  }

  virtual ~AccumuloProxy_getTableProperties_result() throw() {}

  std::map<std::string, std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getTableProperties_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_getTableProperties_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getTableProperties_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getTableProperties_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getTableProperties_presult__isset {
  _AccumuloProxy_getTableProperties_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_getTableProperties_presult__isset;

class AccumuloProxy_getTableProperties_presult {
 public:


  virtual ~AccumuloProxy_getTableProperties_presult() throw() {}

  std::map<std::string, std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_getTableProperties_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_importDirectory_args__isset {
  _AccumuloProxy_importDirectory_args__isset() : login(false), tableName(false), importDir(false), failureDir(false), setTime(false) {}
  bool login;
  bool tableName;
  bool importDir;
  bool failureDir;
  bool setTime;
} _AccumuloProxy_importDirectory_args__isset;

class AccumuloProxy_importDirectory_args {
 public:

  AccumuloProxy_importDirectory_args() : login(), tableName(), importDir(), failureDir(), setTime(0) {
  }

  virtual ~AccumuloProxy_importDirectory_args() throw() {}

  std::string login;
  std::string tableName;
  std::string importDir;
  std::string failureDir;
  bool setTime;

  _AccumuloProxy_importDirectory_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_importDir(const std::string& val) {
    importDir = val;
  }

  void __set_failureDir(const std::string& val) {
    failureDir = val;
  }

  void __set_setTime(const bool val) {
    setTime = val;
  }

  bool operator == (const AccumuloProxy_importDirectory_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(importDir == rhs.importDir))
      return false;
    if (!(failureDir == rhs.failureDir))
      return false;
    if (!(setTime == rhs.setTime))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_importDirectory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_importDirectory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_importDirectory_pargs {
 public:


  virtual ~AccumuloProxy_importDirectory_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* importDir;
  const std::string* failureDir;
  const bool* setTime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_importDirectory_result__isset {
  _AccumuloProxy_importDirectory_result__isset() : ouch1(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_importDirectory_result__isset;

class AccumuloProxy_importDirectory_result {
 public:

  AccumuloProxy_importDirectory_result() {
  }

  virtual ~AccumuloProxy_importDirectory_result() throw() {}

  TableNotFoundException ouch1;
  AccumuloException ouch3;
  AccumuloSecurityException ouch4;

  _AccumuloProxy_importDirectory_result__isset __isset;

  void __set_ouch1(const TableNotFoundException& val) {
    ouch1 = val;
  }

  void __set_ouch3(const AccumuloException& val) {
    ouch3 = val;
  }

  void __set_ouch4(const AccumuloSecurityException& val) {
    ouch4 = val;
  }

  bool operator == (const AccumuloProxy_importDirectory_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    if (!(ouch4 == rhs.ouch4))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_importDirectory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_importDirectory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_importDirectory_presult__isset {
  _AccumuloProxy_importDirectory_presult__isset() : ouch1(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_importDirectory_presult__isset;

class AccumuloProxy_importDirectory_presult {
 public:


  virtual ~AccumuloProxy_importDirectory_presult() throw() {}

  TableNotFoundException ouch1;
  AccumuloException ouch3;
  AccumuloSecurityException ouch4;

  _AccumuloProxy_importDirectory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_importTable_args__isset {
  _AccumuloProxy_importTable_args__isset() : login(false), tableName(false), importDir(false) {}
  bool login;
  bool tableName;
  bool importDir;
} _AccumuloProxy_importTable_args__isset;

class AccumuloProxy_importTable_args {
 public:

  AccumuloProxy_importTable_args() : login(), tableName(), importDir() {
  }

  virtual ~AccumuloProxy_importTable_args() throw() {}

  std::string login;
  std::string tableName;
  std::string importDir;

  _AccumuloProxy_importTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_importDir(const std::string& val) {
    importDir = val;
  }

  bool operator == (const AccumuloProxy_importTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(importDir == rhs.importDir))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_importTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_importTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_importTable_pargs {
 public:


  virtual ~AccumuloProxy_importTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* importDir;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_importTable_result__isset {
  _AccumuloProxy_importTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_importTable_result__isset;

class AccumuloProxy_importTable_result {
 public:

  AccumuloProxy_importTable_result() {
  }

  virtual ~AccumuloProxy_importTable_result() throw() {}

  TableExistsException ouch1;
  AccumuloException ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_importTable_result__isset __isset;

  void __set_ouch1(const TableExistsException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloSecurityException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_importTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_importTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_importTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_importTable_presult__isset {
  _AccumuloProxy_importTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_importTable_presult__isset;

class AccumuloProxy_importTable_presult {
 public:


  virtual ~AccumuloProxy_importTable_presult() throw() {}

  TableExistsException ouch1;
  AccumuloException ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_importTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_listSplits_args__isset {
  _AccumuloProxy_listSplits_args__isset() : login(false), tableName(false), maxSplits(false) {}
  bool login;
  bool tableName;
  bool maxSplits;
} _AccumuloProxy_listSplits_args__isset;

class AccumuloProxy_listSplits_args {
 public:

  AccumuloProxy_listSplits_args() : login(), tableName(), maxSplits(0) {
  }

  virtual ~AccumuloProxy_listSplits_args() throw() {}

  std::string login;
  std::string tableName;
  int32_t maxSplits;

  _AccumuloProxy_listSplits_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_maxSplits(const int32_t val) {
    maxSplits = val;
  }

  bool operator == (const AccumuloProxy_listSplits_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(maxSplits == rhs.maxSplits))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listSplits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listSplits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_listSplits_pargs {
 public:


  virtual ~AccumuloProxy_listSplits_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const int32_t* maxSplits;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listSplits_result__isset {
  _AccumuloProxy_listSplits_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listSplits_result__isset;

class AccumuloProxy_listSplits_result {
 public:

  AccumuloProxy_listSplits_result() {
  }

  virtual ~AccumuloProxy_listSplits_result() throw() {}

  std::vector<std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listSplits_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_listSplits_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listSplits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listSplits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listSplits_presult__isset {
  _AccumuloProxy_listSplits_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listSplits_presult__isset;

class AccumuloProxy_listSplits_presult {
 public:


  virtual ~AccumuloProxy_listSplits_presult() throw() {}

  std::vector<std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listSplits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_listTables_args__isset {
  _AccumuloProxy_listTables_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_listTables_args__isset;

class AccumuloProxy_listTables_args {
 public:

  AccumuloProxy_listTables_args() : login() {
  }

  virtual ~AccumuloProxy_listTables_args() throw() {}

  std::string login;

  _AccumuloProxy_listTables_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_listTables_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listTables_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listTables_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_listTables_pargs {
 public:


  virtual ~AccumuloProxy_listTables_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listTables_result__isset {
  _AccumuloProxy_listTables_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_listTables_result__isset;

class AccumuloProxy_listTables_result {
 public:

  AccumuloProxy_listTables_result() {
  }

  virtual ~AccumuloProxy_listTables_result() throw() {}

  std::set<std::string>  success;

  _AccumuloProxy_listTables_result__isset __isset;

  void __set_success(const std::set<std::string> & val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_listTables_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listTables_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listTables_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listTables_presult__isset {
  _AccumuloProxy_listTables_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_listTables_presult__isset;

class AccumuloProxy_listTables_presult {
 public:


  virtual ~AccumuloProxy_listTables_presult() throw() {}

  std::set<std::string> * success;

  _AccumuloProxy_listTables_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_listIterators_args__isset {
  _AccumuloProxy_listIterators_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_listIterators_args__isset;

class AccumuloProxy_listIterators_args {
 public:

  AccumuloProxy_listIterators_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_listIterators_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_listIterators_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_listIterators_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listIterators_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listIterators_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_listIterators_pargs {
 public:


  virtual ~AccumuloProxy_listIterators_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listIterators_result__isset {
  _AccumuloProxy_listIterators_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listIterators_result__isset;

class AccumuloProxy_listIterators_result {
 public:

  AccumuloProxy_listIterators_result() {
  }

  virtual ~AccumuloProxy_listIterators_result() throw() {}

  std::map<std::string, std::set<IteratorScope::type> >  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listIterators_result__isset __isset;

  void __set_success(const std::map<std::string, std::set<IteratorScope::type> > & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_listIterators_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listIterators_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listIterators_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listIterators_presult__isset {
  _AccumuloProxy_listIterators_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listIterators_presult__isset;

class AccumuloProxy_listIterators_presult {
 public:


  virtual ~AccumuloProxy_listIterators_presult() throw() {}

  std::map<std::string, std::set<IteratorScope::type> > * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listIterators_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_listConstraints_args__isset {
  _AccumuloProxy_listConstraints_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_listConstraints_args__isset;

class AccumuloProxy_listConstraints_args {
 public:

  AccumuloProxy_listConstraints_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_listConstraints_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_listConstraints_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_listConstraints_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listConstraints_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listConstraints_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_listConstraints_pargs {
 public:


  virtual ~AccumuloProxy_listConstraints_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listConstraints_result__isset {
  _AccumuloProxy_listConstraints_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listConstraints_result__isset;

class AccumuloProxy_listConstraints_result {
 public:

  AccumuloProxy_listConstraints_result() {
  }

  virtual ~AccumuloProxy_listConstraints_result() throw() {}

  std::map<std::string, int32_t>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listConstraints_result__isset __isset;

  void __set_success(const std::map<std::string, int32_t> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_listConstraints_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listConstraints_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listConstraints_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listConstraints_presult__isset {
  _AccumuloProxy_listConstraints_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listConstraints_presult__isset;

class AccumuloProxy_listConstraints_presult {
 public:


  virtual ~AccumuloProxy_listConstraints_presult() throw() {}

  std::map<std::string, int32_t> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listConstraints_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_mergeTablets_args__isset {
  _AccumuloProxy_mergeTablets_args__isset() : login(false), tableName(false), startRow(false), endRow(false) {}
  bool login;
  bool tableName;
  bool startRow;
  bool endRow;
} _AccumuloProxy_mergeTablets_args__isset;

class AccumuloProxy_mergeTablets_args {
 public:

  AccumuloProxy_mergeTablets_args() : login(), tableName(), startRow(), endRow() {
  }

  virtual ~AccumuloProxy_mergeTablets_args() throw() {}

  std::string login;
  std::string tableName;
  std::string startRow;
  std::string endRow;

  _AccumuloProxy_mergeTablets_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_startRow(const std::string& val) {
    startRow = val;
  }

  void __set_endRow(const std::string& val) {
    endRow = val;
  }

  bool operator == (const AccumuloProxy_mergeTablets_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(endRow == rhs.endRow))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_mergeTablets_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_mergeTablets_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_mergeTablets_pargs {
 public:


  virtual ~AccumuloProxy_mergeTablets_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* startRow;
  const std::string* endRow;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_mergeTablets_result__isset {
  _AccumuloProxy_mergeTablets_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_mergeTablets_result__isset;

class AccumuloProxy_mergeTablets_result {
 public:

  AccumuloProxy_mergeTablets_result() {
  }

  virtual ~AccumuloProxy_mergeTablets_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_mergeTablets_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_mergeTablets_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_mergeTablets_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_mergeTablets_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_mergeTablets_presult__isset {
  _AccumuloProxy_mergeTablets_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_mergeTablets_presult__isset;

class AccumuloProxy_mergeTablets_presult {
 public:


  virtual ~AccumuloProxy_mergeTablets_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_mergeTablets_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_offlineTable_args__isset {
  _AccumuloProxy_offlineTable_args__isset() : login(false), tableName(false), wait(true) {}
  bool login;
  bool tableName;
  bool wait;
} _AccumuloProxy_offlineTable_args__isset;

class AccumuloProxy_offlineTable_args {
 public:

  AccumuloProxy_offlineTable_args() : login(), tableName(), wait(false) {
  }

  virtual ~AccumuloProxy_offlineTable_args() throw() {}

  std::string login;
  std::string tableName;
  bool wait;

  _AccumuloProxy_offlineTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_wait(const bool val) {
    wait = val;
  }

  bool operator == (const AccumuloProxy_offlineTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(wait == rhs.wait))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_offlineTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_offlineTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_offlineTable_pargs {
 public:


  virtual ~AccumuloProxy_offlineTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const bool* wait;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_offlineTable_result__isset {
  _AccumuloProxy_offlineTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_offlineTable_result__isset;

class AccumuloProxy_offlineTable_result {
 public:

  AccumuloProxy_offlineTable_result() {
  }

  virtual ~AccumuloProxy_offlineTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_offlineTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_offlineTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_offlineTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_offlineTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_offlineTable_presult__isset {
  _AccumuloProxy_offlineTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_offlineTable_presult__isset;

class AccumuloProxy_offlineTable_presult {
 public:


  virtual ~AccumuloProxy_offlineTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_offlineTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_onlineTable_args__isset {
  _AccumuloProxy_onlineTable_args__isset() : login(false), tableName(false), wait(true) {}
  bool login;
  bool tableName;
  bool wait;
} _AccumuloProxy_onlineTable_args__isset;

class AccumuloProxy_onlineTable_args {
 public:

  AccumuloProxy_onlineTable_args() : login(), tableName(), wait(false) {
  }

  virtual ~AccumuloProxy_onlineTable_args() throw() {}

  std::string login;
  std::string tableName;
  bool wait;

  _AccumuloProxy_onlineTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_wait(const bool val) {
    wait = val;
  }

  bool operator == (const AccumuloProxy_onlineTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(wait == rhs.wait))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_onlineTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_onlineTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_onlineTable_pargs {
 public:


  virtual ~AccumuloProxy_onlineTable_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const bool* wait;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_onlineTable_result__isset {
  _AccumuloProxy_onlineTable_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_onlineTable_result__isset;

class AccumuloProxy_onlineTable_result {
 public:

  AccumuloProxy_onlineTable_result() {
  }

  virtual ~AccumuloProxy_onlineTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_onlineTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_onlineTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_onlineTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_onlineTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_onlineTable_presult__isset {
  _AccumuloProxy_onlineTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_onlineTable_presult__isset;

class AccumuloProxy_onlineTable_presult {
 public:


  virtual ~AccumuloProxy_onlineTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_onlineTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_removeConstraint_args__isset {
  _AccumuloProxy_removeConstraint_args__isset() : login(false), tableName(false), constraint(false) {}
  bool login;
  bool tableName;
  bool constraint;
} _AccumuloProxy_removeConstraint_args__isset;

class AccumuloProxy_removeConstraint_args {
 public:

  AccumuloProxy_removeConstraint_args() : login(), tableName(), constraint(0) {
  }

  virtual ~AccumuloProxy_removeConstraint_args() throw() {}

  std::string login;
  std::string tableName;
  int32_t constraint;

  _AccumuloProxy_removeConstraint_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_constraint(const int32_t val) {
    constraint = val;
  }

  bool operator == (const AccumuloProxy_removeConstraint_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(constraint == rhs.constraint))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeConstraint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeConstraint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_removeConstraint_pargs {
 public:


  virtual ~AccumuloProxy_removeConstraint_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const int32_t* constraint;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeConstraint_result__isset {
  _AccumuloProxy_removeConstraint_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeConstraint_result__isset;

class AccumuloProxy_removeConstraint_result {
 public:

  AccumuloProxy_removeConstraint_result() {
  }

  virtual ~AccumuloProxy_removeConstraint_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeConstraint_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_removeConstraint_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeConstraint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeConstraint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeConstraint_presult__isset {
  _AccumuloProxy_removeConstraint_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeConstraint_presult__isset;

class AccumuloProxy_removeConstraint_presult {
 public:


  virtual ~AccumuloProxy_removeConstraint_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeConstraint_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_removeIterator_args__isset {
  _AccumuloProxy_removeIterator_args__isset() : login(false), tableName(false), iterName(false), scopes(false) {}
  bool login;
  bool tableName;
  bool iterName;
  bool scopes;
} _AccumuloProxy_removeIterator_args__isset;

class AccumuloProxy_removeIterator_args {
 public:

  AccumuloProxy_removeIterator_args() : login(), tableName(), iterName() {
  }

  virtual ~AccumuloProxy_removeIterator_args() throw() {}

  std::string login;
  std::string tableName;
  std::string iterName;
  std::set<IteratorScope::type>  scopes;

  _AccumuloProxy_removeIterator_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_iterName(const std::string& val) {
    iterName = val;
  }

  void __set_scopes(const std::set<IteratorScope::type> & val) {
    scopes = val;
  }

  bool operator == (const AccumuloProxy_removeIterator_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(iterName == rhs.iterName))
      return false;
    if (!(scopes == rhs.scopes))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeIterator_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeIterator_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_removeIterator_pargs {
 public:


  virtual ~AccumuloProxy_removeIterator_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* iterName;
  const std::set<IteratorScope::type> * scopes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeIterator_result__isset {
  _AccumuloProxy_removeIterator_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeIterator_result__isset;

class AccumuloProxy_removeIterator_result {
 public:

  AccumuloProxy_removeIterator_result() {
  }

  virtual ~AccumuloProxy_removeIterator_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeIterator_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_removeIterator_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeIterator_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeIterator_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeIterator_presult__isset {
  _AccumuloProxy_removeIterator_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeIterator_presult__isset;

class AccumuloProxy_removeIterator_presult {
 public:


  virtual ~AccumuloProxy_removeIterator_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeIterator_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_removeTableProperty_args__isset {
  _AccumuloProxy_removeTableProperty_args__isset() : login(false), tableName(false), property(false) {}
  bool login;
  bool tableName;
  bool property;
} _AccumuloProxy_removeTableProperty_args__isset;

class AccumuloProxy_removeTableProperty_args {
 public:

  AccumuloProxy_removeTableProperty_args() : login(), tableName(), property() {
  }

  virtual ~AccumuloProxy_removeTableProperty_args() throw() {}

  std::string login;
  std::string tableName;
  std::string property;

  _AccumuloProxy_removeTableProperty_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_property(const std::string& val) {
    property = val;
  }

  bool operator == (const AccumuloProxy_removeTableProperty_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(property == rhs.property))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeTableProperty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeTableProperty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_removeTableProperty_pargs {
 public:


  virtual ~AccumuloProxy_removeTableProperty_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* property;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeTableProperty_result__isset {
  _AccumuloProxy_removeTableProperty_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeTableProperty_result__isset;

class AccumuloProxy_removeTableProperty_result {
 public:

  AccumuloProxy_removeTableProperty_result() {
  }

  virtual ~AccumuloProxy_removeTableProperty_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeTableProperty_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_removeTableProperty_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeTableProperty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeTableProperty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeTableProperty_presult__isset {
  _AccumuloProxy_removeTableProperty_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_removeTableProperty_presult__isset;

class AccumuloProxy_removeTableProperty_presult {
 public:


  virtual ~AccumuloProxy_removeTableProperty_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_removeTableProperty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_renameTable_args__isset {
  _AccumuloProxy_renameTable_args__isset() : login(false), oldTableName(false), newTableName(false) {}
  bool login;
  bool oldTableName;
  bool newTableName;
} _AccumuloProxy_renameTable_args__isset;

class AccumuloProxy_renameTable_args {
 public:

  AccumuloProxy_renameTable_args() : login(), oldTableName(), newTableName() {
  }

  virtual ~AccumuloProxy_renameTable_args() throw() {}

  std::string login;
  std::string oldTableName;
  std::string newTableName;

  _AccumuloProxy_renameTable_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_oldTableName(const std::string& val) {
    oldTableName = val;
  }

  void __set_newTableName(const std::string& val) {
    newTableName = val;
  }

  bool operator == (const AccumuloProxy_renameTable_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(oldTableName == rhs.oldTableName))
      return false;
    if (!(newTableName == rhs.newTableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_renameTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_renameTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_renameTable_pargs {
 public:


  virtual ~AccumuloProxy_renameTable_pargs() throw() {}

  const std::string* login;
  const std::string* oldTableName;
  const std::string* newTableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_renameTable_result__isset {
  _AccumuloProxy_renameTable_result__isset() : ouch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_renameTable_result__isset;

class AccumuloProxy_renameTable_result {
 public:

  AccumuloProxy_renameTable_result() {
  }

  virtual ~AccumuloProxy_renameTable_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  TableExistsException ouch4;

  _AccumuloProxy_renameTable_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  void __set_ouch4(const TableExistsException& val) {
    ouch4 = val;
  }

  bool operator == (const AccumuloProxy_renameTable_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    if (!(ouch4 == rhs.ouch4))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_renameTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_renameTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_renameTable_presult__isset {
  _AccumuloProxy_renameTable_presult__isset() : ouch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_renameTable_presult__isset;

class AccumuloProxy_renameTable_presult {
 public:


  virtual ~AccumuloProxy_renameTable_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  TableExistsException ouch4;

  _AccumuloProxy_renameTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_setLocalityGroups_args__isset {
  _AccumuloProxy_setLocalityGroups_args__isset() : login(false), tableName(false), groups(false) {}
  bool login;
  bool tableName;
  bool groups;
} _AccumuloProxy_setLocalityGroups_args__isset;

class AccumuloProxy_setLocalityGroups_args {
 public:

  AccumuloProxy_setLocalityGroups_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_setLocalityGroups_args() throw() {}

  std::string login;
  std::string tableName;
  std::map<std::string, std::set<std::string> >  groups;

  _AccumuloProxy_setLocalityGroups_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_groups(const std::map<std::string, std::set<std::string> > & val) {
    groups = val;
  }

  bool operator == (const AccumuloProxy_setLocalityGroups_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(groups == rhs.groups))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setLocalityGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setLocalityGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_setLocalityGroups_pargs {
 public:


  virtual ~AccumuloProxy_setLocalityGroups_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::map<std::string, std::set<std::string> > * groups;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setLocalityGroups_result__isset {
  _AccumuloProxy_setLocalityGroups_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_setLocalityGroups_result__isset;

class AccumuloProxy_setLocalityGroups_result {
 public:

  AccumuloProxy_setLocalityGroups_result() {
  }

  virtual ~AccumuloProxy_setLocalityGroups_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_setLocalityGroups_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_setLocalityGroups_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setLocalityGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setLocalityGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setLocalityGroups_presult__isset {
  _AccumuloProxy_setLocalityGroups_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_setLocalityGroups_presult__isset;

class AccumuloProxy_setLocalityGroups_presult {
 public:


  virtual ~AccumuloProxy_setLocalityGroups_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_setLocalityGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_setTableProperty_args__isset {
  _AccumuloProxy_setTableProperty_args__isset() : login(false), tableName(false), property(false), value(false) {}
  bool login;
  bool tableName;
  bool property;
  bool value;
} _AccumuloProxy_setTableProperty_args__isset;

class AccumuloProxy_setTableProperty_args {
 public:

  AccumuloProxy_setTableProperty_args() : login(), tableName(), property(), value() {
  }

  virtual ~AccumuloProxy_setTableProperty_args() throw() {}

  std::string login;
  std::string tableName;
  std::string property;
  std::string value;

  _AccumuloProxy_setTableProperty_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_property(const std::string& val) {
    property = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const AccumuloProxy_setTableProperty_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(property == rhs.property))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setTableProperty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setTableProperty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_setTableProperty_pargs {
 public:


  virtual ~AccumuloProxy_setTableProperty_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* property;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setTableProperty_result__isset {
  _AccumuloProxy_setTableProperty_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_setTableProperty_result__isset;

class AccumuloProxy_setTableProperty_result {
 public:

  AccumuloProxy_setTableProperty_result() {
  }

  virtual ~AccumuloProxy_setTableProperty_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_setTableProperty_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_setTableProperty_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setTableProperty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setTableProperty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setTableProperty_presult__isset {
  _AccumuloProxy_setTableProperty_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_setTableProperty_presult__isset;

class AccumuloProxy_setTableProperty_presult {
 public:


  virtual ~AccumuloProxy_setTableProperty_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_setTableProperty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_splitRangeByTablets_args__isset {
  _AccumuloProxy_splitRangeByTablets_args__isset() : login(false), tableName(false), range(false), maxSplits(false) {}
  bool login;
  bool tableName;
  bool range;
  bool maxSplits;
} _AccumuloProxy_splitRangeByTablets_args__isset;

class AccumuloProxy_splitRangeByTablets_args {
 public:

  AccumuloProxy_splitRangeByTablets_args() : login(), tableName(), maxSplits(0) {
  }

  virtual ~AccumuloProxy_splitRangeByTablets_args() throw() {}

  std::string login;
  std::string tableName;
  Range range;
  int32_t maxSplits;

  _AccumuloProxy_splitRangeByTablets_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_range(const Range& val) {
    range = val;
  }

  void __set_maxSplits(const int32_t val) {
    maxSplits = val;
  }

  bool operator == (const AccumuloProxy_splitRangeByTablets_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(maxSplits == rhs.maxSplits))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_splitRangeByTablets_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_splitRangeByTablets_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_splitRangeByTablets_pargs {
 public:


  virtual ~AccumuloProxy_splitRangeByTablets_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const Range* range;
  const int32_t* maxSplits;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_splitRangeByTablets_result__isset {
  _AccumuloProxy_splitRangeByTablets_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_splitRangeByTablets_result__isset;

class AccumuloProxy_splitRangeByTablets_result {
 public:

  AccumuloProxy_splitRangeByTablets_result() {
  }

  virtual ~AccumuloProxy_splitRangeByTablets_result() throw() {}

  std::set<Range>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_splitRangeByTablets_result__isset __isset;

  void __set_success(const std::set<Range> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_splitRangeByTablets_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_splitRangeByTablets_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_splitRangeByTablets_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_splitRangeByTablets_presult__isset {
  _AccumuloProxy_splitRangeByTablets_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_splitRangeByTablets_presult__isset;

class AccumuloProxy_splitRangeByTablets_presult {
 public:


  virtual ~AccumuloProxy_splitRangeByTablets_presult() throw() {}

  std::set<Range> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_splitRangeByTablets_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_tableExists_args__isset {
  _AccumuloProxy_tableExists_args__isset() : login(false), tableName(false) {}
  bool login;
  bool tableName;
} _AccumuloProxy_tableExists_args__isset;

class AccumuloProxy_tableExists_args {
 public:

  AccumuloProxy_tableExists_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_tableExists_args() throw() {}

  std::string login;
  std::string tableName;

  _AccumuloProxy_tableExists_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  bool operator == (const AccumuloProxy_tableExists_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_tableExists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_tableExists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_tableExists_pargs {
 public:


  virtual ~AccumuloProxy_tableExists_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_tableExists_result__isset {
  _AccumuloProxy_tableExists_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_tableExists_result__isset;

class AccumuloProxy_tableExists_result {
 public:

  AccumuloProxy_tableExists_result() : success(0) {
  }

  virtual ~AccumuloProxy_tableExists_result() throw() {}

  bool success;

  _AccumuloProxy_tableExists_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_tableExists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_tableExists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_tableExists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_tableExists_presult__isset {
  _AccumuloProxy_tableExists_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_tableExists_presult__isset;

class AccumuloProxy_tableExists_presult {
 public:


  virtual ~AccumuloProxy_tableExists_presult() throw() {}

  bool* success;

  _AccumuloProxy_tableExists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_tableIdMap_args__isset {
  _AccumuloProxy_tableIdMap_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_tableIdMap_args__isset;

class AccumuloProxy_tableIdMap_args {
 public:

  AccumuloProxy_tableIdMap_args() : login() {
  }

  virtual ~AccumuloProxy_tableIdMap_args() throw() {}

  std::string login;

  _AccumuloProxy_tableIdMap_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_tableIdMap_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_tableIdMap_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_tableIdMap_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_tableIdMap_pargs {
 public:


  virtual ~AccumuloProxy_tableIdMap_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_tableIdMap_result__isset {
  _AccumuloProxy_tableIdMap_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_tableIdMap_result__isset;

class AccumuloProxy_tableIdMap_result {
 public:

  AccumuloProxy_tableIdMap_result() {
  }

  virtual ~AccumuloProxy_tableIdMap_result() throw() {}

  std::map<std::string, std::string>  success;

  _AccumuloProxy_tableIdMap_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_tableIdMap_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_tableIdMap_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_tableIdMap_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_tableIdMap_presult__isset {
  _AccumuloProxy_tableIdMap_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_tableIdMap_presult__isset;

class AccumuloProxy_tableIdMap_presult {
 public:


  virtual ~AccumuloProxy_tableIdMap_presult() throw() {}

  std::map<std::string, std::string> * success;

  _AccumuloProxy_tableIdMap_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_testTableClassLoad_args__isset {
  _AccumuloProxy_testTableClassLoad_args__isset() : login(false), tableName(false), className(false), asTypeName(false) {}
  bool login;
  bool tableName;
  bool className;
  bool asTypeName;
} _AccumuloProxy_testTableClassLoad_args__isset;

class AccumuloProxy_testTableClassLoad_args {
 public:

  AccumuloProxy_testTableClassLoad_args() : login(), tableName(), className(), asTypeName() {
  }

  virtual ~AccumuloProxy_testTableClassLoad_args() throw() {}

  std::string login;
  std::string tableName;
  std::string className;
  std::string asTypeName;

  _AccumuloProxy_testTableClassLoad_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_className(const std::string& val) {
    className = val;
  }

  void __set_asTypeName(const std::string& val) {
    asTypeName = val;
  }

  bool operator == (const AccumuloProxy_testTableClassLoad_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(className == rhs.className))
      return false;
    if (!(asTypeName == rhs.asTypeName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_testTableClassLoad_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_testTableClassLoad_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_testTableClassLoad_pargs {
 public:


  virtual ~AccumuloProxy_testTableClassLoad_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* className;
  const std::string* asTypeName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_testTableClassLoad_result__isset {
  _AccumuloProxy_testTableClassLoad_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_testTableClassLoad_result__isset;

class AccumuloProxy_testTableClassLoad_result {
 public:

  AccumuloProxy_testTableClassLoad_result() : success(0) {
  }

  virtual ~AccumuloProxy_testTableClassLoad_result() throw() {}

  bool success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_testTableClassLoad_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_testTableClassLoad_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_testTableClassLoad_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_testTableClassLoad_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_testTableClassLoad_presult__isset {
  _AccumuloProxy_testTableClassLoad_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_testTableClassLoad_presult__isset;

class AccumuloProxy_testTableClassLoad_presult {
 public:


  virtual ~AccumuloProxy_testTableClassLoad_presult() throw() {}

  bool* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_testTableClassLoad_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_pingTabletServer_args__isset {
  _AccumuloProxy_pingTabletServer_args__isset() : login(false), tserver(false) {}
  bool login;
  bool tserver;
} _AccumuloProxy_pingTabletServer_args__isset;

class AccumuloProxy_pingTabletServer_args {
 public:

  AccumuloProxy_pingTabletServer_args() : login(), tserver() {
  }

  virtual ~AccumuloProxy_pingTabletServer_args() throw() {}

  std::string login;
  std::string tserver;

  _AccumuloProxy_pingTabletServer_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tserver(const std::string& val) {
    tserver = val;
  }

  bool operator == (const AccumuloProxy_pingTabletServer_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tserver == rhs.tserver))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_pingTabletServer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_pingTabletServer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_pingTabletServer_pargs {
 public:


  virtual ~AccumuloProxy_pingTabletServer_pargs() throw() {}

  const std::string* login;
  const std::string* tserver;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_pingTabletServer_result__isset {
  _AccumuloProxy_pingTabletServer_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_pingTabletServer_result__isset;

class AccumuloProxy_pingTabletServer_result {
 public:

  AccumuloProxy_pingTabletServer_result() {
  }

  virtual ~AccumuloProxy_pingTabletServer_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_pingTabletServer_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_pingTabletServer_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_pingTabletServer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_pingTabletServer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_pingTabletServer_presult__isset {
  _AccumuloProxy_pingTabletServer_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_pingTabletServer_presult__isset;

class AccumuloProxy_pingTabletServer_presult {
 public:


  virtual ~AccumuloProxy_pingTabletServer_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_pingTabletServer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getActiveScans_args__isset {
  _AccumuloProxy_getActiveScans_args__isset() : login(false), tserver(false) {}
  bool login;
  bool tserver;
} _AccumuloProxy_getActiveScans_args__isset;

class AccumuloProxy_getActiveScans_args {
 public:

  AccumuloProxy_getActiveScans_args() : login(), tserver() {
  }

  virtual ~AccumuloProxy_getActiveScans_args() throw() {}

  std::string login;
  std::string tserver;

  _AccumuloProxy_getActiveScans_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tserver(const std::string& val) {
    tserver = val;
  }

  bool operator == (const AccumuloProxy_getActiveScans_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tserver == rhs.tserver))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getActiveScans_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getActiveScans_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getActiveScans_pargs {
 public:


  virtual ~AccumuloProxy_getActiveScans_pargs() throw() {}

  const std::string* login;
  const std::string* tserver;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getActiveScans_result__isset {
  _AccumuloProxy_getActiveScans_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getActiveScans_result__isset;

class AccumuloProxy_getActiveScans_result {
 public:

  AccumuloProxy_getActiveScans_result() {
  }

  virtual ~AccumuloProxy_getActiveScans_result() throw() {}

  std::vector<ActiveScan>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getActiveScans_result__isset __isset;

  void __set_success(const std::vector<ActiveScan> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_getActiveScans_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getActiveScans_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getActiveScans_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getActiveScans_presult__isset {
  _AccumuloProxy_getActiveScans_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getActiveScans_presult__isset;

class AccumuloProxy_getActiveScans_presult {
 public:


  virtual ~AccumuloProxy_getActiveScans_presult() throw() {}

  std::vector<ActiveScan> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getActiveScans_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getActiveCompactions_args__isset {
  _AccumuloProxy_getActiveCompactions_args__isset() : login(false), tserver(false) {}
  bool login;
  bool tserver;
} _AccumuloProxy_getActiveCompactions_args__isset;

class AccumuloProxy_getActiveCompactions_args {
 public:

  AccumuloProxy_getActiveCompactions_args() : login(), tserver() {
  }

  virtual ~AccumuloProxy_getActiveCompactions_args() throw() {}

  std::string login;
  std::string tserver;

  _AccumuloProxy_getActiveCompactions_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tserver(const std::string& val) {
    tserver = val;
  }

  bool operator == (const AccumuloProxy_getActiveCompactions_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tserver == rhs.tserver))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getActiveCompactions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getActiveCompactions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getActiveCompactions_pargs {
 public:


  virtual ~AccumuloProxy_getActiveCompactions_pargs() throw() {}

  const std::string* login;
  const std::string* tserver;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getActiveCompactions_result__isset {
  _AccumuloProxy_getActiveCompactions_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getActiveCompactions_result__isset;

class AccumuloProxy_getActiveCompactions_result {
 public:

  AccumuloProxy_getActiveCompactions_result() {
  }

  virtual ~AccumuloProxy_getActiveCompactions_result() throw() {}

  std::vector<ActiveCompaction>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getActiveCompactions_result__isset __isset;

  void __set_success(const std::vector<ActiveCompaction> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_getActiveCompactions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getActiveCompactions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getActiveCompactions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getActiveCompactions_presult__isset {
  _AccumuloProxy_getActiveCompactions_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getActiveCompactions_presult__isset;

class AccumuloProxy_getActiveCompactions_presult {
 public:


  virtual ~AccumuloProxy_getActiveCompactions_presult() throw() {}

  std::vector<ActiveCompaction> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getActiveCompactions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getSiteConfiguration_args__isset {
  _AccumuloProxy_getSiteConfiguration_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_getSiteConfiguration_args__isset;

class AccumuloProxy_getSiteConfiguration_args {
 public:

  AccumuloProxy_getSiteConfiguration_args() : login() {
  }

  virtual ~AccumuloProxy_getSiteConfiguration_args() throw() {}

  std::string login;

  _AccumuloProxy_getSiteConfiguration_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_getSiteConfiguration_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getSiteConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getSiteConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getSiteConfiguration_pargs {
 public:


  virtual ~AccumuloProxy_getSiteConfiguration_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getSiteConfiguration_result__isset {
  _AccumuloProxy_getSiteConfiguration_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getSiteConfiguration_result__isset;

class AccumuloProxy_getSiteConfiguration_result {
 public:

  AccumuloProxy_getSiteConfiguration_result() {
  }

  virtual ~AccumuloProxy_getSiteConfiguration_result() throw() {}

  std::map<std::string, std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getSiteConfiguration_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_getSiteConfiguration_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getSiteConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getSiteConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getSiteConfiguration_presult__isset {
  _AccumuloProxy_getSiteConfiguration_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getSiteConfiguration_presult__isset;

class AccumuloProxy_getSiteConfiguration_presult {
 public:


  virtual ~AccumuloProxy_getSiteConfiguration_presult() throw() {}

  std::map<std::string, std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getSiteConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getSystemConfiguration_args__isset {
  _AccumuloProxy_getSystemConfiguration_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_getSystemConfiguration_args__isset;

class AccumuloProxy_getSystemConfiguration_args {
 public:

  AccumuloProxy_getSystemConfiguration_args() : login() {
  }

  virtual ~AccumuloProxy_getSystemConfiguration_args() throw() {}

  std::string login;

  _AccumuloProxy_getSystemConfiguration_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_getSystemConfiguration_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getSystemConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getSystemConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getSystemConfiguration_pargs {
 public:


  virtual ~AccumuloProxy_getSystemConfiguration_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getSystemConfiguration_result__isset {
  _AccumuloProxy_getSystemConfiguration_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getSystemConfiguration_result__isset;

class AccumuloProxy_getSystemConfiguration_result {
 public:

  AccumuloProxy_getSystemConfiguration_result() {
  }

  virtual ~AccumuloProxy_getSystemConfiguration_result() throw() {}

  std::map<std::string, std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getSystemConfiguration_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_getSystemConfiguration_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getSystemConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getSystemConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getSystemConfiguration_presult__isset {
  _AccumuloProxy_getSystemConfiguration_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getSystemConfiguration_presult__isset;

class AccumuloProxy_getSystemConfiguration_presult {
 public:


  virtual ~AccumuloProxy_getSystemConfiguration_presult() throw() {}

  std::map<std::string, std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getSystemConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getTabletServers_args__isset {
  _AccumuloProxy_getTabletServers_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_getTabletServers_args__isset;

class AccumuloProxy_getTabletServers_args {
 public:

  AccumuloProxy_getTabletServers_args() : login() {
  }

  virtual ~AccumuloProxy_getTabletServers_args() throw() {}

  std::string login;

  _AccumuloProxy_getTabletServers_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_getTabletServers_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getTabletServers_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getTabletServers_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getTabletServers_pargs {
 public:


  virtual ~AccumuloProxy_getTabletServers_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getTabletServers_result__isset {
  _AccumuloProxy_getTabletServers_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getTabletServers_result__isset;

class AccumuloProxy_getTabletServers_result {
 public:

  AccumuloProxy_getTabletServers_result() {
  }

  virtual ~AccumuloProxy_getTabletServers_result() throw() {}

  std::vector<std::string>  success;

  _AccumuloProxy_getTabletServers_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_getTabletServers_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getTabletServers_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getTabletServers_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getTabletServers_presult__isset {
  _AccumuloProxy_getTabletServers_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getTabletServers_presult__isset;

class AccumuloProxy_getTabletServers_presult {
 public:


  virtual ~AccumuloProxy_getTabletServers_presult() throw() {}

  std::vector<std::string> * success;

  _AccumuloProxy_getTabletServers_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_removeProperty_args__isset {
  _AccumuloProxy_removeProperty_args__isset() : login(false), property(false) {}
  bool login;
  bool property;
} _AccumuloProxy_removeProperty_args__isset;

class AccumuloProxy_removeProperty_args {
 public:

  AccumuloProxy_removeProperty_args() : login(), property() {
  }

  virtual ~AccumuloProxy_removeProperty_args() throw() {}

  std::string login;
  std::string property;

  _AccumuloProxy_removeProperty_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_property(const std::string& val) {
    property = val;
  }

  bool operator == (const AccumuloProxy_removeProperty_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(property == rhs.property))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeProperty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeProperty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_removeProperty_pargs {
 public:


  virtual ~AccumuloProxy_removeProperty_pargs() throw() {}

  const std::string* login;
  const std::string* property;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeProperty_result__isset {
  _AccumuloProxy_removeProperty_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_removeProperty_result__isset;

class AccumuloProxy_removeProperty_result {
 public:

  AccumuloProxy_removeProperty_result() {
  }

  virtual ~AccumuloProxy_removeProperty_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_removeProperty_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_removeProperty_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_removeProperty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_removeProperty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_removeProperty_presult__isset {
  _AccumuloProxy_removeProperty_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_removeProperty_presult__isset;

class AccumuloProxy_removeProperty_presult {
 public:


  virtual ~AccumuloProxy_removeProperty_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_removeProperty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_setProperty_args__isset {
  _AccumuloProxy_setProperty_args__isset() : login(false), property(false), value(false) {}
  bool login;
  bool property;
  bool value;
} _AccumuloProxy_setProperty_args__isset;

class AccumuloProxy_setProperty_args {
 public:

  AccumuloProxy_setProperty_args() : login(), property(), value() {
  }

  virtual ~AccumuloProxy_setProperty_args() throw() {}

  std::string login;
  std::string property;
  std::string value;

  _AccumuloProxy_setProperty_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_property(const std::string& val) {
    property = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const AccumuloProxy_setProperty_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(property == rhs.property))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setProperty_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setProperty_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_setProperty_pargs {
 public:


  virtual ~AccumuloProxy_setProperty_pargs() throw() {}

  const std::string* login;
  const std::string* property;
  const std::string* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setProperty_result__isset {
  _AccumuloProxy_setProperty_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_setProperty_result__isset;

class AccumuloProxy_setProperty_result {
 public:

  AccumuloProxy_setProperty_result() {
  }

  virtual ~AccumuloProxy_setProperty_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_setProperty_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_setProperty_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_setProperty_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_setProperty_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_setProperty_presult__isset {
  _AccumuloProxy_setProperty_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_setProperty_presult__isset;

class AccumuloProxy_setProperty_presult {
 public:


  virtual ~AccumuloProxy_setProperty_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_setProperty_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_testClassLoad_args__isset {
  _AccumuloProxy_testClassLoad_args__isset() : login(false), className(false), asTypeName(false) {}
  bool login;
  bool className;
  bool asTypeName;
} _AccumuloProxy_testClassLoad_args__isset;

class AccumuloProxy_testClassLoad_args {
 public:

  AccumuloProxy_testClassLoad_args() : login(), className(), asTypeName() {
  }

  virtual ~AccumuloProxy_testClassLoad_args() throw() {}

  std::string login;
  std::string className;
  std::string asTypeName;

  _AccumuloProxy_testClassLoad_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_className(const std::string& val) {
    className = val;
  }

  void __set_asTypeName(const std::string& val) {
    asTypeName = val;
  }

  bool operator == (const AccumuloProxy_testClassLoad_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(className == rhs.className))
      return false;
    if (!(asTypeName == rhs.asTypeName))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_testClassLoad_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_testClassLoad_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_testClassLoad_pargs {
 public:


  virtual ~AccumuloProxy_testClassLoad_pargs() throw() {}

  const std::string* login;
  const std::string* className;
  const std::string* asTypeName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_testClassLoad_result__isset {
  _AccumuloProxy_testClassLoad_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_testClassLoad_result__isset;

class AccumuloProxy_testClassLoad_result {
 public:

  AccumuloProxy_testClassLoad_result() : success(0) {
  }

  virtual ~AccumuloProxy_testClassLoad_result() throw() {}

  bool success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_testClassLoad_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_testClassLoad_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_testClassLoad_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_testClassLoad_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_testClassLoad_presult__isset {
  _AccumuloProxy_testClassLoad_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_testClassLoad_presult__isset;

class AccumuloProxy_testClassLoad_presult {
 public:


  virtual ~AccumuloProxy_testClassLoad_presult() throw() {}

  bool* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_testClassLoad_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_authenticateUser_args__isset {
  _AccumuloProxy_authenticateUser_args__isset() : login(false), user(false), properties(false) {}
  bool login;
  bool user;
  bool properties;
} _AccumuloProxy_authenticateUser_args__isset;

class AccumuloProxy_authenticateUser_args {
 public:

  AccumuloProxy_authenticateUser_args() : login(), user() {
  }

  virtual ~AccumuloProxy_authenticateUser_args() throw() {}

  std::string login;
  std::string user;
  std::map<std::string, std::string>  properties;

  _AccumuloProxy_authenticateUser_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_properties(const std::map<std::string, std::string> & val) {
    properties = val;
  }

  bool operator == (const AccumuloProxy_authenticateUser_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_authenticateUser_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_authenticateUser_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_authenticateUser_pargs {
 public:


  virtual ~AccumuloProxy_authenticateUser_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::map<std::string, std::string> * properties;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_authenticateUser_result__isset {
  _AccumuloProxy_authenticateUser_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_authenticateUser_result__isset;

class AccumuloProxy_authenticateUser_result {
 public:

  AccumuloProxy_authenticateUser_result() : success(0) {
  }

  virtual ~AccumuloProxy_authenticateUser_result() throw() {}

  bool success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_authenticateUser_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_authenticateUser_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_authenticateUser_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_authenticateUser_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_authenticateUser_presult__isset {
  _AccumuloProxy_authenticateUser_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_authenticateUser_presult__isset;

class AccumuloProxy_authenticateUser_presult {
 public:


  virtual ~AccumuloProxy_authenticateUser_presult() throw() {}

  bool* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_authenticateUser_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_changeUserAuthorizations_args__isset {
  _AccumuloProxy_changeUserAuthorizations_args__isset() : login(false), user(false), authorizations(false) {}
  bool login;
  bool user;
  bool authorizations;
} _AccumuloProxy_changeUserAuthorizations_args__isset;

class AccumuloProxy_changeUserAuthorizations_args {
 public:

  AccumuloProxy_changeUserAuthorizations_args() : login(), user() {
  }

  virtual ~AccumuloProxy_changeUserAuthorizations_args() throw() {}

  std::string login;
  std::string user;
  std::set<std::string>  authorizations;

  _AccumuloProxy_changeUserAuthorizations_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_authorizations(const std::set<std::string> & val) {
    authorizations = val;
  }

  bool operator == (const AccumuloProxy_changeUserAuthorizations_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(authorizations == rhs.authorizations))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_changeUserAuthorizations_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_changeUserAuthorizations_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_changeUserAuthorizations_pargs {
 public:


  virtual ~AccumuloProxy_changeUserAuthorizations_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::set<std::string> * authorizations;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_changeUserAuthorizations_result__isset {
  _AccumuloProxy_changeUserAuthorizations_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_changeUserAuthorizations_result__isset;

class AccumuloProxy_changeUserAuthorizations_result {
 public:

  AccumuloProxy_changeUserAuthorizations_result() {
  }

  virtual ~AccumuloProxy_changeUserAuthorizations_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_changeUserAuthorizations_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_changeUserAuthorizations_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_changeUserAuthorizations_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_changeUserAuthorizations_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_changeUserAuthorizations_presult__isset {
  _AccumuloProxy_changeUserAuthorizations_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_changeUserAuthorizations_presult__isset;

class AccumuloProxy_changeUserAuthorizations_presult {
 public:


  virtual ~AccumuloProxy_changeUserAuthorizations_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_changeUserAuthorizations_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_changeLocalUserPassword_args__isset {
  _AccumuloProxy_changeLocalUserPassword_args__isset() : login(false), user(false), password(false) {}
  bool login;
  bool user;
  bool password;
} _AccumuloProxy_changeLocalUserPassword_args__isset;

class AccumuloProxy_changeLocalUserPassword_args {
 public:

  AccumuloProxy_changeLocalUserPassword_args() : login(), user(), password() {
  }

  virtual ~AccumuloProxy_changeLocalUserPassword_args() throw() {}

  std::string login;
  std::string user;
  std::string password;

  _AccumuloProxy_changeLocalUserPassword_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const AccumuloProxy_changeLocalUserPassword_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_changeLocalUserPassword_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_changeLocalUserPassword_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_changeLocalUserPassword_pargs {
 public:


  virtual ~AccumuloProxy_changeLocalUserPassword_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::string* password;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_changeLocalUserPassword_result__isset {
  _AccumuloProxy_changeLocalUserPassword_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_changeLocalUserPassword_result__isset;

class AccumuloProxy_changeLocalUserPassword_result {
 public:

  AccumuloProxy_changeLocalUserPassword_result() {
  }

  virtual ~AccumuloProxy_changeLocalUserPassword_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_changeLocalUserPassword_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_changeLocalUserPassword_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_changeLocalUserPassword_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_changeLocalUserPassword_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_changeLocalUserPassword_presult__isset {
  _AccumuloProxy_changeLocalUserPassword_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_changeLocalUserPassword_presult__isset;

class AccumuloProxy_changeLocalUserPassword_presult {
 public:


  virtual ~AccumuloProxy_changeLocalUserPassword_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_changeLocalUserPassword_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createLocalUser_args__isset {
  _AccumuloProxy_createLocalUser_args__isset() : login(false), user(false), password(false) {}
  bool login;
  bool user;
  bool password;
} _AccumuloProxy_createLocalUser_args__isset;

class AccumuloProxy_createLocalUser_args {
 public:

  AccumuloProxy_createLocalUser_args() : login(), user(), password() {
  }

  virtual ~AccumuloProxy_createLocalUser_args() throw() {}

  std::string login;
  std::string user;
  std::string password;

  _AccumuloProxy_createLocalUser_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  bool operator == (const AccumuloProxy_createLocalUser_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createLocalUser_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createLocalUser_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createLocalUser_pargs {
 public:


  virtual ~AccumuloProxy_createLocalUser_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::string* password;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createLocalUser_result__isset {
  _AccumuloProxy_createLocalUser_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_createLocalUser_result__isset;

class AccumuloProxy_createLocalUser_result {
 public:

  AccumuloProxy_createLocalUser_result() {
  }

  virtual ~AccumuloProxy_createLocalUser_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_createLocalUser_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_createLocalUser_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createLocalUser_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createLocalUser_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createLocalUser_presult__isset {
  _AccumuloProxy_createLocalUser_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_createLocalUser_presult__isset;

class AccumuloProxy_createLocalUser_presult {
 public:


  virtual ~AccumuloProxy_createLocalUser_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_createLocalUser_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_dropLocalUser_args__isset {
  _AccumuloProxy_dropLocalUser_args__isset() : login(false), user(false) {}
  bool login;
  bool user;
} _AccumuloProxy_dropLocalUser_args__isset;

class AccumuloProxy_dropLocalUser_args {
 public:

  AccumuloProxy_dropLocalUser_args() : login(), user() {
  }

  virtual ~AccumuloProxy_dropLocalUser_args() throw() {}

  std::string login;
  std::string user;

  _AccumuloProxy_dropLocalUser_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  bool operator == (const AccumuloProxy_dropLocalUser_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_dropLocalUser_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_dropLocalUser_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_dropLocalUser_pargs {
 public:


  virtual ~AccumuloProxy_dropLocalUser_pargs() throw() {}

  const std::string* login;
  const std::string* user;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_dropLocalUser_result__isset {
  _AccumuloProxy_dropLocalUser_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_dropLocalUser_result__isset;

class AccumuloProxy_dropLocalUser_result {
 public:

  AccumuloProxy_dropLocalUser_result() {
  }

  virtual ~AccumuloProxy_dropLocalUser_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_dropLocalUser_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_dropLocalUser_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_dropLocalUser_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_dropLocalUser_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_dropLocalUser_presult__isset {
  _AccumuloProxy_dropLocalUser_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_dropLocalUser_presult__isset;

class AccumuloProxy_dropLocalUser_presult {
 public:


  virtual ~AccumuloProxy_dropLocalUser_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_dropLocalUser_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getUserAuthorizations_args__isset {
  _AccumuloProxy_getUserAuthorizations_args__isset() : login(false), user(false) {}
  bool login;
  bool user;
} _AccumuloProxy_getUserAuthorizations_args__isset;

class AccumuloProxy_getUserAuthorizations_args {
 public:

  AccumuloProxy_getUserAuthorizations_args() : login(), user() {
  }

  virtual ~AccumuloProxy_getUserAuthorizations_args() throw() {}

  std::string login;
  std::string user;

  _AccumuloProxy_getUserAuthorizations_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  bool operator == (const AccumuloProxy_getUserAuthorizations_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getUserAuthorizations_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getUserAuthorizations_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getUserAuthorizations_pargs {
 public:


  virtual ~AccumuloProxy_getUserAuthorizations_pargs() throw() {}

  const std::string* login;
  const std::string* user;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getUserAuthorizations_result__isset {
  _AccumuloProxy_getUserAuthorizations_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getUserAuthorizations_result__isset;

class AccumuloProxy_getUserAuthorizations_result {
 public:

  AccumuloProxy_getUserAuthorizations_result() {
  }

  virtual ~AccumuloProxy_getUserAuthorizations_result() throw() {}

  std::vector<std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getUserAuthorizations_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_getUserAuthorizations_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getUserAuthorizations_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getUserAuthorizations_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getUserAuthorizations_presult__isset {
  _AccumuloProxy_getUserAuthorizations_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_getUserAuthorizations_presult__isset;

class AccumuloProxy_getUserAuthorizations_presult {
 public:


  virtual ~AccumuloProxy_getUserAuthorizations_presult() throw() {}

  std::vector<std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_getUserAuthorizations_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_grantSystemPermission_args__isset {
  _AccumuloProxy_grantSystemPermission_args__isset() : login(false), user(false), perm(false) {}
  bool login;
  bool user;
  bool perm;
} _AccumuloProxy_grantSystemPermission_args__isset;

class AccumuloProxy_grantSystemPermission_args {
 public:

  AccumuloProxy_grantSystemPermission_args() : login(), user(), perm((SystemPermission::type)0) {
  }

  virtual ~AccumuloProxy_grantSystemPermission_args() throw() {}

  std::string login;
  std::string user;
  SystemPermission::type perm;

  _AccumuloProxy_grantSystemPermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_perm(const SystemPermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_grantSystemPermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_grantSystemPermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_grantSystemPermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_grantSystemPermission_pargs {
 public:


  virtual ~AccumuloProxy_grantSystemPermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const SystemPermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_grantSystemPermission_result__isset {
  _AccumuloProxy_grantSystemPermission_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_grantSystemPermission_result__isset;

class AccumuloProxy_grantSystemPermission_result {
 public:

  AccumuloProxy_grantSystemPermission_result() {
  }

  virtual ~AccumuloProxy_grantSystemPermission_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_grantSystemPermission_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_grantSystemPermission_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_grantSystemPermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_grantSystemPermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_grantSystemPermission_presult__isset {
  _AccumuloProxy_grantSystemPermission_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_grantSystemPermission_presult__isset;

class AccumuloProxy_grantSystemPermission_presult {
 public:


  virtual ~AccumuloProxy_grantSystemPermission_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_grantSystemPermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_grantTablePermission_args__isset {
  _AccumuloProxy_grantTablePermission_args__isset() : login(false), user(false), table(false), perm(false) {}
  bool login;
  bool user;
  bool table;
  bool perm;
} _AccumuloProxy_grantTablePermission_args__isset;

class AccumuloProxy_grantTablePermission_args {
 public:

  AccumuloProxy_grantTablePermission_args() : login(), user(), table(), perm((TablePermission::type)0) {
  }

  virtual ~AccumuloProxy_grantTablePermission_args() throw() {}

  std::string login;
  std::string user;
  std::string table;
  TablePermission::type perm;

  _AccumuloProxy_grantTablePermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_table(const std::string& val) {
    table = val;
  }

  void __set_perm(const TablePermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_grantTablePermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_grantTablePermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_grantTablePermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_grantTablePermission_pargs {
 public:


  virtual ~AccumuloProxy_grantTablePermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::string* table;
  const TablePermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_grantTablePermission_result__isset {
  _AccumuloProxy_grantTablePermission_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_grantTablePermission_result__isset;

class AccumuloProxy_grantTablePermission_result {
 public:

  AccumuloProxy_grantTablePermission_result() {
  }

  virtual ~AccumuloProxy_grantTablePermission_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_grantTablePermission_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_grantTablePermission_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_grantTablePermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_grantTablePermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_grantTablePermission_presult__isset {
  _AccumuloProxy_grantTablePermission_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_grantTablePermission_presult__isset;

class AccumuloProxy_grantTablePermission_presult {
 public:


  virtual ~AccumuloProxy_grantTablePermission_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_grantTablePermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_hasSystemPermission_args__isset {
  _AccumuloProxy_hasSystemPermission_args__isset() : login(false), user(false), perm(false) {}
  bool login;
  bool user;
  bool perm;
} _AccumuloProxy_hasSystemPermission_args__isset;

class AccumuloProxy_hasSystemPermission_args {
 public:

  AccumuloProxy_hasSystemPermission_args() : login(), user(), perm((SystemPermission::type)0) {
  }

  virtual ~AccumuloProxy_hasSystemPermission_args() throw() {}

  std::string login;
  std::string user;
  SystemPermission::type perm;

  _AccumuloProxy_hasSystemPermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_perm(const SystemPermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_hasSystemPermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasSystemPermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasSystemPermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_hasSystemPermission_pargs {
 public:


  virtual ~AccumuloProxy_hasSystemPermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const SystemPermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasSystemPermission_result__isset {
  _AccumuloProxy_hasSystemPermission_result__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_hasSystemPermission_result__isset;

class AccumuloProxy_hasSystemPermission_result {
 public:

  AccumuloProxy_hasSystemPermission_result() : success(0) {
  }

  virtual ~AccumuloProxy_hasSystemPermission_result() throw() {}

  bool success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_hasSystemPermission_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_hasSystemPermission_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasSystemPermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasSystemPermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasSystemPermission_presult__isset {
  _AccumuloProxy_hasSystemPermission_presult__isset() : success(false), ouch1(false), ouch2(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_hasSystemPermission_presult__isset;

class AccumuloProxy_hasSystemPermission_presult {
 public:


  virtual ~AccumuloProxy_hasSystemPermission_presult() throw() {}

  bool* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_hasSystemPermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_hasTablePermission_args__isset {
  _AccumuloProxy_hasTablePermission_args__isset() : login(false), user(false), table(false), perm(false) {}
  bool login;
  bool user;
  bool table;
  bool perm;
} _AccumuloProxy_hasTablePermission_args__isset;

class AccumuloProxy_hasTablePermission_args {
 public:

  AccumuloProxy_hasTablePermission_args() : login(), user(), table(), perm((TablePermission::type)0) {
  }

  virtual ~AccumuloProxy_hasTablePermission_args() throw() {}

  std::string login;
  std::string user;
  std::string table;
  TablePermission::type perm;

  _AccumuloProxy_hasTablePermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_table(const std::string& val) {
    table = val;
  }

  void __set_perm(const TablePermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_hasTablePermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasTablePermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasTablePermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_hasTablePermission_pargs {
 public:


  virtual ~AccumuloProxy_hasTablePermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::string* table;
  const TablePermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasTablePermission_result__isset {
  _AccumuloProxy_hasTablePermission_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_hasTablePermission_result__isset;

class AccumuloProxy_hasTablePermission_result {
 public:

  AccumuloProxy_hasTablePermission_result() : success(0) {
  }

  virtual ~AccumuloProxy_hasTablePermission_result() throw() {}

  bool success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_hasTablePermission_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_hasTablePermission_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasTablePermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasTablePermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasTablePermission_presult__isset {
  _AccumuloProxy_hasTablePermission_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_hasTablePermission_presult__isset;

class AccumuloProxy_hasTablePermission_presult {
 public:


  virtual ~AccumuloProxy_hasTablePermission_presult() throw() {}

  bool* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_hasTablePermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_listLocalUsers_args__isset {
  _AccumuloProxy_listLocalUsers_args__isset() : login(false) {}
  bool login;
} _AccumuloProxy_listLocalUsers_args__isset;

class AccumuloProxy_listLocalUsers_args {
 public:

  AccumuloProxy_listLocalUsers_args() : login() {
  }

  virtual ~AccumuloProxy_listLocalUsers_args() throw() {}

  std::string login;

  _AccumuloProxy_listLocalUsers_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  bool operator == (const AccumuloProxy_listLocalUsers_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listLocalUsers_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listLocalUsers_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_listLocalUsers_pargs {
 public:


  virtual ~AccumuloProxy_listLocalUsers_pargs() throw() {}

  const std::string* login;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listLocalUsers_result__isset {
  _AccumuloProxy_listLocalUsers_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listLocalUsers_result__isset;

class AccumuloProxy_listLocalUsers_result {
 public:

  AccumuloProxy_listLocalUsers_result() {
  }

  virtual ~AccumuloProxy_listLocalUsers_result() throw() {}

  std::set<std::string>  success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listLocalUsers_result__isset __isset;

  void __set_success(const std::set<std::string> & val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_listLocalUsers_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_listLocalUsers_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_listLocalUsers_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_listLocalUsers_presult__isset {
  _AccumuloProxy_listLocalUsers_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_listLocalUsers_presult__isset;

class AccumuloProxy_listLocalUsers_presult {
 public:


  virtual ~AccumuloProxy_listLocalUsers_presult() throw() {}

  std::set<std::string> * success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_listLocalUsers_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_revokeSystemPermission_args__isset {
  _AccumuloProxy_revokeSystemPermission_args__isset() : login(false), user(false), perm(false) {}
  bool login;
  bool user;
  bool perm;
} _AccumuloProxy_revokeSystemPermission_args__isset;

class AccumuloProxy_revokeSystemPermission_args {
 public:

  AccumuloProxy_revokeSystemPermission_args() : login(), user(), perm((SystemPermission::type)0) {
  }

  virtual ~AccumuloProxy_revokeSystemPermission_args() throw() {}

  std::string login;
  std::string user;
  SystemPermission::type perm;

  _AccumuloProxy_revokeSystemPermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_perm(const SystemPermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_revokeSystemPermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_revokeSystemPermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_revokeSystemPermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_revokeSystemPermission_pargs {
 public:


  virtual ~AccumuloProxy_revokeSystemPermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const SystemPermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_revokeSystemPermission_result__isset {
  _AccumuloProxy_revokeSystemPermission_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_revokeSystemPermission_result__isset;

class AccumuloProxy_revokeSystemPermission_result {
 public:

  AccumuloProxy_revokeSystemPermission_result() {
  }

  virtual ~AccumuloProxy_revokeSystemPermission_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_revokeSystemPermission_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_revokeSystemPermission_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_revokeSystemPermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_revokeSystemPermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_revokeSystemPermission_presult__isset {
  _AccumuloProxy_revokeSystemPermission_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_revokeSystemPermission_presult__isset;

class AccumuloProxy_revokeSystemPermission_presult {
 public:


  virtual ~AccumuloProxy_revokeSystemPermission_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;

  _AccumuloProxy_revokeSystemPermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_revokeTablePermission_args__isset {
  _AccumuloProxy_revokeTablePermission_args__isset() : login(false), user(false), table(false), perm(false) {}
  bool login;
  bool user;
  bool table;
  bool perm;
} _AccumuloProxy_revokeTablePermission_args__isset;

class AccumuloProxy_revokeTablePermission_args {
 public:

  AccumuloProxy_revokeTablePermission_args() : login(), user(), table(), perm((TablePermission::type)0) {
  }

  virtual ~AccumuloProxy_revokeTablePermission_args() throw() {}

  std::string login;
  std::string user;
  std::string table;
  TablePermission::type perm;

  _AccumuloProxy_revokeTablePermission_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_table(const std::string& val) {
    table = val;
  }

  void __set_perm(const TablePermission::type val) {
    perm = val;
  }

  bool operator == (const AccumuloProxy_revokeTablePermission_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(perm == rhs.perm))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_revokeTablePermission_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_revokeTablePermission_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_revokeTablePermission_pargs {
 public:


  virtual ~AccumuloProxy_revokeTablePermission_pargs() throw() {}

  const std::string* login;
  const std::string* user;
  const std::string* table;
  const TablePermission::type* perm;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_revokeTablePermission_result__isset {
  _AccumuloProxy_revokeTablePermission_result__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_revokeTablePermission_result__isset;

class AccumuloProxy_revokeTablePermission_result {
 public:

  AccumuloProxy_revokeTablePermission_result() {
  }

  virtual ~AccumuloProxy_revokeTablePermission_result() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_revokeTablePermission_result__isset __isset;

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_revokeTablePermission_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_revokeTablePermission_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_revokeTablePermission_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_revokeTablePermission_presult__isset {
  _AccumuloProxy_revokeTablePermission_presult__isset() : ouch1(false), ouch2(false), ouch3(false) {}
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_revokeTablePermission_presult__isset;

class AccumuloProxy_revokeTablePermission_presult {
 public:


  virtual ~AccumuloProxy_revokeTablePermission_presult() throw() {}

  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_revokeTablePermission_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createBatchScanner_args__isset {
  _AccumuloProxy_createBatchScanner_args__isset() : login(false), tableName(false), options(false) {}
  bool login;
  bool tableName;
  bool options;
} _AccumuloProxy_createBatchScanner_args__isset;

class AccumuloProxy_createBatchScanner_args {
 public:

  AccumuloProxy_createBatchScanner_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_createBatchScanner_args() throw() {}

  std::string login;
  std::string tableName;
  BatchScanOptions options;

  _AccumuloProxy_createBatchScanner_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_options(const BatchScanOptions& val) {
    options = val;
  }

  bool operator == (const AccumuloProxy_createBatchScanner_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createBatchScanner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createBatchScanner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createBatchScanner_pargs {
 public:


  virtual ~AccumuloProxy_createBatchScanner_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const BatchScanOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createBatchScanner_result__isset {
  _AccumuloProxy_createBatchScanner_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createBatchScanner_result__isset;

class AccumuloProxy_createBatchScanner_result {
 public:

  AccumuloProxy_createBatchScanner_result() : success() {
  }

  virtual ~AccumuloProxy_createBatchScanner_result() throw() {}

  std::string success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createBatchScanner_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_createBatchScanner_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createBatchScanner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createBatchScanner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createBatchScanner_presult__isset {
  _AccumuloProxy_createBatchScanner_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createBatchScanner_presult__isset;

class AccumuloProxy_createBatchScanner_presult {
 public:


  virtual ~AccumuloProxy_createBatchScanner_presult() throw() {}

  std::string* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createBatchScanner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createScanner_args__isset {
  _AccumuloProxy_createScanner_args__isset() : login(false), tableName(false), options(false) {}
  bool login;
  bool tableName;
  bool options;
} _AccumuloProxy_createScanner_args__isset;

class AccumuloProxy_createScanner_args {
 public:

  AccumuloProxy_createScanner_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_createScanner_args() throw() {}

  std::string login;
  std::string tableName;
  ScanOptions options;

  _AccumuloProxy_createScanner_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_options(const ScanOptions& val) {
    options = val;
  }

  bool operator == (const AccumuloProxy_createScanner_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createScanner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createScanner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createScanner_pargs {
 public:


  virtual ~AccumuloProxy_createScanner_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const ScanOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createScanner_result__isset {
  _AccumuloProxy_createScanner_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createScanner_result__isset;

class AccumuloProxy_createScanner_result {
 public:

  AccumuloProxy_createScanner_result() : success() {
  }

  virtual ~AccumuloProxy_createScanner_result() throw() {}

  std::string success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createScanner_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_createScanner_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createScanner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createScanner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createScanner_presult__isset {
  _AccumuloProxy_createScanner_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createScanner_presult__isset;

class AccumuloProxy_createScanner_presult {
 public:


  virtual ~AccumuloProxy_createScanner_presult() throw() {}

  std::string* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createScanner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_hasNext_args__isset {
  _AccumuloProxy_hasNext_args__isset() : scanner(false) {}
  bool scanner;
} _AccumuloProxy_hasNext_args__isset;

class AccumuloProxy_hasNext_args {
 public:

  AccumuloProxy_hasNext_args() : scanner() {
  }

  virtual ~AccumuloProxy_hasNext_args() throw() {}

  std::string scanner;

  _AccumuloProxy_hasNext_args__isset __isset;

  void __set_scanner(const std::string& val) {
    scanner = val;
  }

  bool operator == (const AccumuloProxy_hasNext_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasNext_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasNext_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_hasNext_pargs {
 public:


  virtual ~AccumuloProxy_hasNext_pargs() throw() {}

  const std::string* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasNext_result__isset {
  _AccumuloProxy_hasNext_result__isset() : success(false), ouch1(false) {}
  bool success;
  bool ouch1;
} _AccumuloProxy_hasNext_result__isset;

class AccumuloProxy_hasNext_result {
 public:

  AccumuloProxy_hasNext_result() : success(0) {
  }

  virtual ~AccumuloProxy_hasNext_result() throw() {}

  bool success;
  UnknownScanner ouch1;

  _AccumuloProxy_hasNext_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_ouch1(const UnknownScanner& val) {
    ouch1 = val;
  }

  bool operator == (const AccumuloProxy_hasNext_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_hasNext_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_hasNext_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_hasNext_presult__isset {
  _AccumuloProxy_hasNext_presult__isset() : success(false), ouch1(false) {}
  bool success;
  bool ouch1;
} _AccumuloProxy_hasNext_presult__isset;

class AccumuloProxy_hasNext_presult {
 public:


  virtual ~AccumuloProxy_hasNext_presult() throw() {}

  bool* success;
  UnknownScanner ouch1;

  _AccumuloProxy_hasNext_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_nextEntry_args__isset {
  _AccumuloProxy_nextEntry_args__isset() : scanner(false) {}
  bool scanner;
} _AccumuloProxy_nextEntry_args__isset;

class AccumuloProxy_nextEntry_args {
 public:

  AccumuloProxy_nextEntry_args() : scanner() {
  }

  virtual ~AccumuloProxy_nextEntry_args() throw() {}

  std::string scanner;

  _AccumuloProxy_nextEntry_args__isset __isset;

  void __set_scanner(const std::string& val) {
    scanner = val;
  }

  bool operator == (const AccumuloProxy_nextEntry_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_nextEntry_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_nextEntry_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_nextEntry_pargs {
 public:


  virtual ~AccumuloProxy_nextEntry_pargs() throw() {}

  const std::string* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_nextEntry_result__isset {
  _AccumuloProxy_nextEntry_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_nextEntry_result__isset;

class AccumuloProxy_nextEntry_result {
 public:

  AccumuloProxy_nextEntry_result() {
  }

  virtual ~AccumuloProxy_nextEntry_result() throw() {}

  KeyValueAndPeek success;
  NoMoreEntriesException ouch1;
  UnknownScanner ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_nextEntry_result__isset __isset;

  void __set_success(const KeyValueAndPeek& val) {
    success = val;
  }

  void __set_ouch1(const NoMoreEntriesException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const UnknownScanner& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloSecurityException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_nextEntry_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_nextEntry_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_nextEntry_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_nextEntry_presult__isset {
  _AccumuloProxy_nextEntry_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_nextEntry_presult__isset;

class AccumuloProxy_nextEntry_presult {
 public:


  virtual ~AccumuloProxy_nextEntry_presult() throw() {}

  KeyValueAndPeek* success;
  NoMoreEntriesException ouch1;
  UnknownScanner ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_nextEntry_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_nextK_args__isset {
  _AccumuloProxy_nextK_args__isset() : scanner(false), k(false) {}
  bool scanner;
  bool k;
} _AccumuloProxy_nextK_args__isset;

class AccumuloProxy_nextK_args {
 public:

  AccumuloProxy_nextK_args() : scanner(), k(0) {
  }

  virtual ~AccumuloProxy_nextK_args() throw() {}

  std::string scanner;
  int32_t k;

  _AccumuloProxy_nextK_args__isset __isset;

  void __set_scanner(const std::string& val) {
    scanner = val;
  }

  void __set_k(const int32_t val) {
    k = val;
  }

  bool operator == (const AccumuloProxy_nextK_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    if (!(k == rhs.k))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_nextK_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_nextK_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_nextK_pargs {
 public:


  virtual ~AccumuloProxy_nextK_pargs() throw() {}

  const std::string* scanner;
  const int32_t* k;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_nextK_result__isset {
  _AccumuloProxy_nextK_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_nextK_result__isset;

class AccumuloProxy_nextK_result {
 public:

  AccumuloProxy_nextK_result() {
  }

  virtual ~AccumuloProxy_nextK_result() throw() {}

  ScanResult success;
  NoMoreEntriesException ouch1;
  UnknownScanner ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_nextK_result__isset __isset;

  void __set_success(const ScanResult& val) {
    success = val;
  }

  void __set_ouch1(const NoMoreEntriesException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const UnknownScanner& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloSecurityException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_nextK_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_nextK_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_nextK_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_nextK_presult__isset {
  _AccumuloProxy_nextK_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_nextK_presult__isset;

class AccumuloProxy_nextK_presult {
 public:


  virtual ~AccumuloProxy_nextK_presult() throw() {}

  ScanResult* success;
  NoMoreEntriesException ouch1;
  UnknownScanner ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_nextK_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_closeScanner_args__isset {
  _AccumuloProxy_closeScanner_args__isset() : scanner(false) {}
  bool scanner;
} _AccumuloProxy_closeScanner_args__isset;

class AccumuloProxy_closeScanner_args {
 public:

  AccumuloProxy_closeScanner_args() : scanner() {
  }

  virtual ~AccumuloProxy_closeScanner_args() throw() {}

  std::string scanner;

  _AccumuloProxy_closeScanner_args__isset __isset;

  void __set_scanner(const std::string& val) {
    scanner = val;
  }

  bool operator == (const AccumuloProxy_closeScanner_args & rhs) const
  {
    if (!(scanner == rhs.scanner))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_closeScanner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeScanner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_closeScanner_pargs {
 public:


  virtual ~AccumuloProxy_closeScanner_pargs() throw() {}

  const std::string* scanner;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_closeScanner_result__isset {
  _AccumuloProxy_closeScanner_result__isset() : ouch1(false) {}
  bool ouch1;
} _AccumuloProxy_closeScanner_result__isset;

class AccumuloProxy_closeScanner_result {
 public:

  AccumuloProxy_closeScanner_result() {
  }

  virtual ~AccumuloProxy_closeScanner_result() throw() {}

  UnknownScanner ouch1;

  _AccumuloProxy_closeScanner_result__isset __isset;

  void __set_ouch1(const UnknownScanner& val) {
    ouch1 = val;
  }

  bool operator == (const AccumuloProxy_closeScanner_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_closeScanner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeScanner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_closeScanner_presult__isset {
  _AccumuloProxy_closeScanner_presult__isset() : ouch1(false) {}
  bool ouch1;
} _AccumuloProxy_closeScanner_presult__isset;

class AccumuloProxy_closeScanner_presult {
 public:


  virtual ~AccumuloProxy_closeScanner_presult() throw() {}

  UnknownScanner ouch1;

  _AccumuloProxy_closeScanner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_updateAndFlush_args__isset {
  _AccumuloProxy_updateAndFlush_args__isset() : login(false), tableName(false), cells(false) {}
  bool login;
  bool tableName;
  bool cells;
} _AccumuloProxy_updateAndFlush_args__isset;

class AccumuloProxy_updateAndFlush_args {
 public:

  AccumuloProxy_updateAndFlush_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_updateAndFlush_args() throw() {}

  std::string login;
  std::string tableName;
  std::map<std::string, std::vector<ColumnUpdate> >  cells;

  _AccumuloProxy_updateAndFlush_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_cells(const std::map<std::string, std::vector<ColumnUpdate> > & val) {
    cells = val;
  }

  bool operator == (const AccumuloProxy_updateAndFlush_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateAndFlush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateAndFlush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_updateAndFlush_pargs {
 public:


  virtual ~AccumuloProxy_updateAndFlush_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::map<std::string, std::vector<ColumnUpdate> > * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateAndFlush_result__isset {
  _AccumuloProxy_updateAndFlush_result__isset() : outch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool outch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_updateAndFlush_result__isset;

class AccumuloProxy_updateAndFlush_result {
 public:

  AccumuloProxy_updateAndFlush_result() {
  }

  virtual ~AccumuloProxy_updateAndFlush_result() throw() {}

  AccumuloException outch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  MutationsRejectedException ouch4;

  _AccumuloProxy_updateAndFlush_result__isset __isset;

  void __set_outch1(const AccumuloException& val) {
    outch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  void __set_ouch4(const MutationsRejectedException& val) {
    ouch4 = val;
  }

  bool operator == (const AccumuloProxy_updateAndFlush_result & rhs) const
  {
    if (!(outch1 == rhs.outch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    if (!(ouch4 == rhs.ouch4))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateAndFlush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateAndFlush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateAndFlush_presult__isset {
  _AccumuloProxy_updateAndFlush_presult__isset() : outch1(false), ouch2(false), ouch3(false), ouch4(false) {}
  bool outch1;
  bool ouch2;
  bool ouch3;
  bool ouch4;
} _AccumuloProxy_updateAndFlush_presult__isset;

class AccumuloProxy_updateAndFlush_presult {
 public:


  virtual ~AccumuloProxy_updateAndFlush_presult() throw() {}

  AccumuloException outch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;
  MutationsRejectedException ouch4;

  _AccumuloProxy_updateAndFlush_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createWriter_args__isset {
  _AccumuloProxy_createWriter_args__isset() : login(false), tableName(false), opts(false) {}
  bool login;
  bool tableName;
  bool opts;
} _AccumuloProxy_createWriter_args__isset;

class AccumuloProxy_createWriter_args {
 public:

  AccumuloProxy_createWriter_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_createWriter_args() throw() {}

  std::string login;
  std::string tableName;
  WriterOptions opts;

  _AccumuloProxy_createWriter_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_opts(const WriterOptions& val) {
    opts = val;
  }

  bool operator == (const AccumuloProxy_createWriter_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(opts == rhs.opts))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createWriter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createWriter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createWriter_pargs {
 public:


  virtual ~AccumuloProxy_createWriter_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const WriterOptions* opts;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createWriter_result__isset {
  _AccumuloProxy_createWriter_result__isset() : success(false), outch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool outch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createWriter_result__isset;

class AccumuloProxy_createWriter_result {
 public:

  AccumuloProxy_createWriter_result() : success() {
  }

  virtual ~AccumuloProxy_createWriter_result() throw() {}

  std::string success;
  AccumuloException outch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createWriter_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_outch1(const AccumuloException& val) {
    outch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_createWriter_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(outch1 == rhs.outch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createWriter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createWriter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createWriter_presult__isset {
  _AccumuloProxy_createWriter_presult__isset() : success(false), outch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool outch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createWriter_presult__isset;

class AccumuloProxy_createWriter_presult {
 public:


  virtual ~AccumuloProxy_createWriter_presult() throw() {}

  std::string* success;
  AccumuloException outch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createWriter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_update_args__isset {
  _AccumuloProxy_update_args__isset() : writer(false), cells(false) {}
  bool writer;
  bool cells;
} _AccumuloProxy_update_args__isset;

class AccumuloProxy_update_args {
 public:

  AccumuloProxy_update_args() : writer() {
  }

  virtual ~AccumuloProxy_update_args() throw() {}

  std::string writer;
  std::map<std::string, std::vector<ColumnUpdate> >  cells;

  _AccumuloProxy_update_args__isset __isset;

  void __set_writer(const std::string& val) {
    writer = val;
  }

  void __set_cells(const std::map<std::string, std::vector<ColumnUpdate> > & val) {
    cells = val;
  }

  bool operator == (const AccumuloProxy_update_args & rhs) const
  {
    if (!(writer == rhs.writer))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_update_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_update_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_update_pargs {
 public:


  virtual ~AccumuloProxy_update_pargs() throw() {}

  const std::string* writer;
  const std::map<std::string, std::vector<ColumnUpdate> > * cells;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_flush_args__isset {
  _AccumuloProxy_flush_args__isset() : writer(false) {}
  bool writer;
} _AccumuloProxy_flush_args__isset;

class AccumuloProxy_flush_args {
 public:

  AccumuloProxy_flush_args() : writer() {
  }

  virtual ~AccumuloProxy_flush_args() throw() {}

  std::string writer;

  _AccumuloProxy_flush_args__isset __isset;

  void __set_writer(const std::string& val) {
    writer = val;
  }

  bool operator == (const AccumuloProxy_flush_args & rhs) const
  {
    if (!(writer == rhs.writer))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_flush_pargs {
 public:


  virtual ~AccumuloProxy_flush_pargs() throw() {}

  const std::string* writer;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_flush_result__isset {
  _AccumuloProxy_flush_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_flush_result__isset;

class AccumuloProxy_flush_result {
 public:

  AccumuloProxy_flush_result() {
  }

  virtual ~AccumuloProxy_flush_result() throw() {}

  UnknownWriter ouch1;
  MutationsRejectedException ouch2;

  _AccumuloProxy_flush_result__isset __isset;

  void __set_ouch1(const UnknownWriter& val) {
    ouch1 = val;
  }

  void __set_ouch2(const MutationsRejectedException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_flush_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_flush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_flush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_flush_presult__isset {
  _AccumuloProxy_flush_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_flush_presult__isset;

class AccumuloProxy_flush_presult {
 public:


  virtual ~AccumuloProxy_flush_presult() throw() {}

  UnknownWriter ouch1;
  MutationsRejectedException ouch2;

  _AccumuloProxy_flush_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_closeWriter_args__isset {
  _AccumuloProxy_closeWriter_args__isset() : writer(false) {}
  bool writer;
} _AccumuloProxy_closeWriter_args__isset;

class AccumuloProxy_closeWriter_args {
 public:

  AccumuloProxy_closeWriter_args() : writer() {
  }

  virtual ~AccumuloProxy_closeWriter_args() throw() {}

  std::string writer;

  _AccumuloProxy_closeWriter_args__isset __isset;

  void __set_writer(const std::string& val) {
    writer = val;
  }

  bool operator == (const AccumuloProxy_closeWriter_args & rhs) const
  {
    if (!(writer == rhs.writer))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_closeWriter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeWriter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_closeWriter_pargs {
 public:


  virtual ~AccumuloProxy_closeWriter_pargs() throw() {}

  const std::string* writer;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_closeWriter_result__isset {
  _AccumuloProxy_closeWriter_result__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_closeWriter_result__isset;

class AccumuloProxy_closeWriter_result {
 public:

  AccumuloProxy_closeWriter_result() {
  }

  virtual ~AccumuloProxy_closeWriter_result() throw() {}

  UnknownWriter ouch1;
  MutationsRejectedException ouch2;

  _AccumuloProxy_closeWriter_result__isset __isset;

  void __set_ouch1(const UnknownWriter& val) {
    ouch1 = val;
  }

  void __set_ouch2(const MutationsRejectedException& val) {
    ouch2 = val;
  }

  bool operator == (const AccumuloProxy_closeWriter_result & rhs) const
  {
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_closeWriter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeWriter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_closeWriter_presult__isset {
  _AccumuloProxy_closeWriter_presult__isset() : ouch1(false), ouch2(false) {}
  bool ouch1;
  bool ouch2;
} _AccumuloProxy_closeWriter_presult__isset;

class AccumuloProxy_closeWriter_presult {
 public:


  virtual ~AccumuloProxy_closeWriter_presult() throw() {}

  UnknownWriter ouch1;
  MutationsRejectedException ouch2;

  _AccumuloProxy_closeWriter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_updateRowConditionally_args__isset {
  _AccumuloProxy_updateRowConditionally_args__isset() : login(false), tableName(false), row(false), updates(false) {}
  bool login;
  bool tableName;
  bool row;
  bool updates;
} _AccumuloProxy_updateRowConditionally_args__isset;

class AccumuloProxy_updateRowConditionally_args {
 public:

  AccumuloProxy_updateRowConditionally_args() : login(), tableName(), row() {
  }

  virtual ~AccumuloProxy_updateRowConditionally_args() throw() {}

  std::string login;
  std::string tableName;
  std::string row;
  ConditionalUpdates updates;

  _AccumuloProxy_updateRowConditionally_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_row(const std::string& val) {
    row = val;
  }

  void __set_updates(const ConditionalUpdates& val) {
    updates = val;
  }

  bool operator == (const AccumuloProxy_updateRowConditionally_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateRowConditionally_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateRowConditionally_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_updateRowConditionally_pargs {
 public:


  virtual ~AccumuloProxy_updateRowConditionally_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const std::string* row;
  const ConditionalUpdates* updates;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateRowConditionally_result__isset {
  _AccumuloProxy_updateRowConditionally_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_updateRowConditionally_result__isset;

class AccumuloProxy_updateRowConditionally_result {
 public:

  AccumuloProxy_updateRowConditionally_result() : success((ConditionalStatus::type)0) {
  }

  virtual ~AccumuloProxy_updateRowConditionally_result() throw() {}

  ConditionalStatus::type success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_updateRowConditionally_result__isset __isset;

  void __set_success(const ConditionalStatus::type val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_updateRowConditionally_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateRowConditionally_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateRowConditionally_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateRowConditionally_presult__isset {
  _AccumuloProxy_updateRowConditionally_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_updateRowConditionally_presult__isset;

class AccumuloProxy_updateRowConditionally_presult {
 public:


  virtual ~AccumuloProxy_updateRowConditionally_presult() throw() {}

  ConditionalStatus::type* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_updateRowConditionally_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_createConditionalWriter_args__isset {
  _AccumuloProxy_createConditionalWriter_args__isset() : login(false), tableName(false), options(false) {}
  bool login;
  bool tableName;
  bool options;
} _AccumuloProxy_createConditionalWriter_args__isset;

class AccumuloProxy_createConditionalWriter_args {
 public:

  AccumuloProxy_createConditionalWriter_args() : login(), tableName() {
  }

  virtual ~AccumuloProxy_createConditionalWriter_args() throw() {}

  std::string login;
  std::string tableName;
  ConditionalWriterOptions options;

  _AccumuloProxy_createConditionalWriter_args__isset __isset;

  void __set_login(const std::string& val) {
    login = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_options(const ConditionalWriterOptions& val) {
    options = val;
  }

  bool operator == (const AccumuloProxy_createConditionalWriter_args & rhs) const
  {
    if (!(login == rhs.login))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createConditionalWriter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createConditionalWriter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_createConditionalWriter_pargs {
 public:


  virtual ~AccumuloProxy_createConditionalWriter_pargs() throw() {}

  const std::string* login;
  const std::string* tableName;
  const ConditionalWriterOptions* options;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createConditionalWriter_result__isset {
  _AccumuloProxy_createConditionalWriter_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createConditionalWriter_result__isset;

class AccumuloProxy_createConditionalWriter_result {
 public:

  AccumuloProxy_createConditionalWriter_result() : success() {
  }

  virtual ~AccumuloProxy_createConditionalWriter_result() throw() {}

  std::string success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createConditionalWriter_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ouch1(const AccumuloException& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloSecurityException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const TableNotFoundException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_createConditionalWriter_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_createConditionalWriter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_createConditionalWriter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_createConditionalWriter_presult__isset {
  _AccumuloProxy_createConditionalWriter_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_createConditionalWriter_presult__isset;

class AccumuloProxy_createConditionalWriter_presult {
 public:


  virtual ~AccumuloProxy_createConditionalWriter_presult() throw() {}

  std::string* success;
  AccumuloException ouch1;
  AccumuloSecurityException ouch2;
  TableNotFoundException ouch3;

  _AccumuloProxy_createConditionalWriter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_updateRowsConditionally_args__isset {
  _AccumuloProxy_updateRowsConditionally_args__isset() : conditionalWriter(false), updates(false) {}
  bool conditionalWriter;
  bool updates;
} _AccumuloProxy_updateRowsConditionally_args__isset;

class AccumuloProxy_updateRowsConditionally_args {
 public:

  AccumuloProxy_updateRowsConditionally_args() : conditionalWriter() {
  }

  virtual ~AccumuloProxy_updateRowsConditionally_args() throw() {}

  std::string conditionalWriter;
  std::map<std::string, ConditionalUpdates>  updates;

  _AccumuloProxy_updateRowsConditionally_args__isset __isset;

  void __set_conditionalWriter(const std::string& val) {
    conditionalWriter = val;
  }

  void __set_updates(const std::map<std::string, ConditionalUpdates> & val) {
    updates = val;
  }

  bool operator == (const AccumuloProxy_updateRowsConditionally_args & rhs) const
  {
    if (!(conditionalWriter == rhs.conditionalWriter))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateRowsConditionally_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateRowsConditionally_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_updateRowsConditionally_pargs {
 public:


  virtual ~AccumuloProxy_updateRowsConditionally_pargs() throw() {}

  const std::string* conditionalWriter;
  const std::map<std::string, ConditionalUpdates> * updates;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateRowsConditionally_result__isset {
  _AccumuloProxy_updateRowsConditionally_result__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_updateRowsConditionally_result__isset;

class AccumuloProxy_updateRowsConditionally_result {
 public:

  AccumuloProxy_updateRowsConditionally_result() {
  }

  virtual ~AccumuloProxy_updateRowsConditionally_result() throw() {}

  std::map<std::string, ConditionalStatus::type>  success;
  UnknownWriter ouch1;
  AccumuloException ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_updateRowsConditionally_result__isset __isset;

  void __set_success(const std::map<std::string, ConditionalStatus::type> & val) {
    success = val;
  }

  void __set_ouch1(const UnknownWriter& val) {
    ouch1 = val;
  }

  void __set_ouch2(const AccumuloException& val) {
    ouch2 = val;
  }

  void __set_ouch3(const AccumuloSecurityException& val) {
    ouch3 = val;
  }

  bool operator == (const AccumuloProxy_updateRowsConditionally_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch1 == rhs.ouch1))
      return false;
    if (!(ouch2 == rhs.ouch2))
      return false;
    if (!(ouch3 == rhs.ouch3))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_updateRowsConditionally_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_updateRowsConditionally_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_updateRowsConditionally_presult__isset {
  _AccumuloProxy_updateRowsConditionally_presult__isset() : success(false), ouch1(false), ouch2(false), ouch3(false) {}
  bool success;
  bool ouch1;
  bool ouch2;
  bool ouch3;
} _AccumuloProxy_updateRowsConditionally_presult__isset;

class AccumuloProxy_updateRowsConditionally_presult {
 public:


  virtual ~AccumuloProxy_updateRowsConditionally_presult() throw() {}

  std::map<std::string, ConditionalStatus::type> * success;
  UnknownWriter ouch1;
  AccumuloException ouch2;
  AccumuloSecurityException ouch3;

  _AccumuloProxy_updateRowsConditionally_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_closeConditionalWriter_args__isset {
  _AccumuloProxy_closeConditionalWriter_args__isset() : conditionalWriter(false) {}
  bool conditionalWriter;
} _AccumuloProxy_closeConditionalWriter_args__isset;

class AccumuloProxy_closeConditionalWriter_args {
 public:

  AccumuloProxy_closeConditionalWriter_args() : conditionalWriter() {
  }

  virtual ~AccumuloProxy_closeConditionalWriter_args() throw() {}

  std::string conditionalWriter;

  _AccumuloProxy_closeConditionalWriter_args__isset __isset;

  void __set_conditionalWriter(const std::string& val) {
    conditionalWriter = val;
  }

  bool operator == (const AccumuloProxy_closeConditionalWriter_args & rhs) const
  {
    if (!(conditionalWriter == rhs.conditionalWriter))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_closeConditionalWriter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeConditionalWriter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_closeConditionalWriter_pargs {
 public:


  virtual ~AccumuloProxy_closeConditionalWriter_pargs() throw() {}

  const std::string* conditionalWriter;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_closeConditionalWriter_result {
 public:

  AccumuloProxy_closeConditionalWriter_result() {
  }

  virtual ~AccumuloProxy_closeConditionalWriter_result() throw() {}


  bool operator == (const AccumuloProxy_closeConditionalWriter_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AccumuloProxy_closeConditionalWriter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_closeConditionalWriter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_closeConditionalWriter_presult {
 public:


  virtual ~AccumuloProxy_closeConditionalWriter_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getRowRange_args__isset {
  _AccumuloProxy_getRowRange_args__isset() : row(false) {}
  bool row;
} _AccumuloProxy_getRowRange_args__isset;

class AccumuloProxy_getRowRange_args {
 public:

  AccumuloProxy_getRowRange_args() : row() {
  }

  virtual ~AccumuloProxy_getRowRange_args() throw() {}

  std::string row;

  _AccumuloProxy_getRowRange_args__isset __isset;

  void __set_row(const std::string& val) {
    row = val;
  }

  bool operator == (const AccumuloProxy_getRowRange_args & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getRowRange_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getRowRange_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getRowRange_pargs {
 public:


  virtual ~AccumuloProxy_getRowRange_pargs() throw() {}

  const std::string* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getRowRange_result__isset {
  _AccumuloProxy_getRowRange_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getRowRange_result__isset;

class AccumuloProxy_getRowRange_result {
 public:

  AccumuloProxy_getRowRange_result() {
  }

  virtual ~AccumuloProxy_getRowRange_result() throw() {}

  Range success;

  _AccumuloProxy_getRowRange_result__isset __isset;

  void __set_success(const Range& val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_getRowRange_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getRowRange_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getRowRange_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getRowRange_presult__isset {
  _AccumuloProxy_getRowRange_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getRowRange_presult__isset;

class AccumuloProxy_getRowRange_presult {
 public:


  virtual ~AccumuloProxy_getRowRange_presult() throw() {}

  Range* success;

  _AccumuloProxy_getRowRange_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AccumuloProxy_getFollowing_args__isset {
  _AccumuloProxy_getFollowing_args__isset() : key(false), part(false) {}
  bool key;
  bool part;
} _AccumuloProxy_getFollowing_args__isset;

class AccumuloProxy_getFollowing_args {
 public:

  AccumuloProxy_getFollowing_args() : part((PartialKey::type)0) {
  }

  virtual ~AccumuloProxy_getFollowing_args() throw() {}

  Key key;
  PartialKey::type part;

  _AccumuloProxy_getFollowing_args__isset __isset;

  void __set_key(const Key& val) {
    key = val;
  }

  void __set_part(const PartialKey::type val) {
    part = val;
  }

  bool operator == (const AccumuloProxy_getFollowing_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(part == rhs.part))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getFollowing_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getFollowing_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AccumuloProxy_getFollowing_pargs {
 public:


  virtual ~AccumuloProxy_getFollowing_pargs() throw() {}

  const Key* key;
  const PartialKey::type* part;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getFollowing_result__isset {
  _AccumuloProxy_getFollowing_result__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getFollowing_result__isset;

class AccumuloProxy_getFollowing_result {
 public:

  AccumuloProxy_getFollowing_result() {
  }

  virtual ~AccumuloProxy_getFollowing_result() throw() {}

  Key success;

  _AccumuloProxy_getFollowing_result__isset __isset;

  void __set_success(const Key& val) {
    success = val;
  }

  bool operator == (const AccumuloProxy_getFollowing_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const AccumuloProxy_getFollowing_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AccumuloProxy_getFollowing_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _AccumuloProxy_getFollowing_presult__isset {
  _AccumuloProxy_getFollowing_presult__isset() : success(false) {}
  bool success;
} _AccumuloProxy_getFollowing_presult__isset;

class AccumuloProxy_getFollowing_presult {
 public:


  virtual ~AccumuloProxy_getFollowing_presult() throw() {}

  Key* success;

  _AccumuloProxy_getFollowing_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class AccumuloProxyClient : virtual public AccumuloProxyIf {
 public:
  AccumuloProxyClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  AccumuloProxyClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void login(std::string& _return, const std::string& principal, const std::map<std::string, std::string> & loginProperties);
  void send_login(const std::string& principal, const std::map<std::string, std::string> & loginProperties);
  void recv_login(std::string& _return);
  int32_t addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName);
  void send_addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName);
  int32_t recv_addConstraint();
  void addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits);
  void send_addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits);
  void recv_addSplits();
  void attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes);
  void send_attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes);
  void recv_attachIterator();
  void checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes);
  void send_checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes);
  void recv_checkIteratorConflicts();
  void clearLocatorCache(const std::string& login, const std::string& tableName);
  void send_clearLocatorCache(const std::string& login, const std::string& tableName);
  void recv_clearLocatorCache();
  void cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude);
  void send_cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude);
  void recv_cloneTable();
  void compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait);
  void send_compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait);
  void recv_compactTable();
  void cancelCompaction(const std::string& login, const std::string& tableName);
  void send_cancelCompaction(const std::string& login, const std::string& tableName);
  void recv_cancelCompaction();
  void createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type);
  void send_createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type);
  void recv_createTable();
  void deleteTable(const std::string& login, const std::string& tableName);
  void send_deleteTable(const std::string& login, const std::string& tableName);
  void recv_deleteTable();
  void deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow);
  void send_deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow);
  void recv_deleteRows();
  void exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir);
  void send_exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir);
  void recv_exportTable();
  void flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait);
  void send_flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait);
  void recv_flushTable();
  void getDiskUsage(std::vector<DiskUsage> & _return, const std::string& login, const std::set<std::string> & tables);
  void send_getDiskUsage(const std::string& login, const std::set<std::string> & tables);
  void recv_getDiskUsage(std::vector<DiskUsage> & _return);
  void getLocalityGroups(std::map<std::string, std::set<std::string> > & _return, const std::string& login, const std::string& tableName);
  void send_getLocalityGroups(const std::string& login, const std::string& tableName);
  void recv_getLocalityGroups(std::map<std::string, std::set<std::string> > & _return);
  void getIteratorSetting(IteratorSetting& _return, const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope);
  void send_getIteratorSetting(const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope);
  void recv_getIteratorSetting(IteratorSetting& _return);
  void getMaxRow(std::string& _return, const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive);
  void send_getMaxRow(const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive);
  void recv_getMaxRow(std::string& _return);
  void getTableProperties(std::map<std::string, std::string> & _return, const std::string& login, const std::string& tableName);
  void send_getTableProperties(const std::string& login, const std::string& tableName);
  void recv_getTableProperties(std::map<std::string, std::string> & _return);
  void importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime);
  void send_importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime);
  void recv_importDirectory();
  void importTable(const std::string& login, const std::string& tableName, const std::string& importDir);
  void send_importTable(const std::string& login, const std::string& tableName, const std::string& importDir);
  void recv_importTable();
  void listSplits(std::vector<std::string> & _return, const std::string& login, const std::string& tableName, const int32_t maxSplits);
  void send_listSplits(const std::string& login, const std::string& tableName, const int32_t maxSplits);
  void recv_listSplits(std::vector<std::string> & _return);
  void listTables(std::set<std::string> & _return, const std::string& login);
  void send_listTables(const std::string& login);
  void recv_listTables(std::set<std::string> & _return);
  void listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return, const std::string& login, const std::string& tableName);
  void send_listIterators(const std::string& login, const std::string& tableName);
  void recv_listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return);
  void listConstraints(std::map<std::string, int32_t> & _return, const std::string& login, const std::string& tableName);
  void send_listConstraints(const std::string& login, const std::string& tableName);
  void recv_listConstraints(std::map<std::string, int32_t> & _return);
  void mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow);
  void send_mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow);
  void recv_mergeTablets();
  void offlineTable(const std::string& login, const std::string& tableName, const bool wait);
  void send_offlineTable(const std::string& login, const std::string& tableName, const bool wait);
  void recv_offlineTable();
  void onlineTable(const std::string& login, const std::string& tableName, const bool wait);
  void send_onlineTable(const std::string& login, const std::string& tableName, const bool wait);
  void recv_onlineTable();
  void removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint);
  void send_removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint);
  void recv_removeConstraint();
  void removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes);
  void send_removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes);
  void recv_removeIterator();
  void removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property);
  void send_removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property);
  void recv_removeTableProperty();
  void renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName);
  void send_renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName);
  void recv_renameTable();
  void setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups);
  void send_setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups);
  void recv_setLocalityGroups();
  void setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value);
  void send_setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value);
  void recv_setTableProperty();
  void splitRangeByTablets(std::set<Range> & _return, const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits);
  void send_splitRangeByTablets(const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits);
  void recv_splitRangeByTablets(std::set<Range> & _return);
  bool tableExists(const std::string& login, const std::string& tableName);
  void send_tableExists(const std::string& login, const std::string& tableName);
  bool recv_tableExists();
  void tableIdMap(std::map<std::string, std::string> & _return, const std::string& login);
  void send_tableIdMap(const std::string& login);
  void recv_tableIdMap(std::map<std::string, std::string> & _return);
  bool testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName);
  void send_testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName);
  bool recv_testTableClassLoad();
  void pingTabletServer(const std::string& login, const std::string& tserver);
  void send_pingTabletServer(const std::string& login, const std::string& tserver);
  void recv_pingTabletServer();
  void getActiveScans(std::vector<ActiveScan> & _return, const std::string& login, const std::string& tserver);
  void send_getActiveScans(const std::string& login, const std::string& tserver);
  void recv_getActiveScans(std::vector<ActiveScan> & _return);
  void getActiveCompactions(std::vector<ActiveCompaction> & _return, const std::string& login, const std::string& tserver);
  void send_getActiveCompactions(const std::string& login, const std::string& tserver);
  void recv_getActiveCompactions(std::vector<ActiveCompaction> & _return);
  void getSiteConfiguration(std::map<std::string, std::string> & _return, const std::string& login);
  void send_getSiteConfiguration(const std::string& login);
  void recv_getSiteConfiguration(std::map<std::string, std::string> & _return);
  void getSystemConfiguration(std::map<std::string, std::string> & _return, const std::string& login);
  void send_getSystemConfiguration(const std::string& login);
  void recv_getSystemConfiguration(std::map<std::string, std::string> & _return);
  void getTabletServers(std::vector<std::string> & _return, const std::string& login);
  void send_getTabletServers(const std::string& login);
  void recv_getTabletServers(std::vector<std::string> & _return);
  void removeProperty(const std::string& login, const std::string& property);
  void send_removeProperty(const std::string& login, const std::string& property);
  void recv_removeProperty();
  void setProperty(const std::string& login, const std::string& property, const std::string& value);
  void send_setProperty(const std::string& login, const std::string& property, const std::string& value);
  void recv_setProperty();
  bool testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName);
  void send_testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName);
  bool recv_testClassLoad();
  bool authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties);
  void send_authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties);
  bool recv_authenticateUser();
  void changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations);
  void send_changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations);
  void recv_changeUserAuthorizations();
  void changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password);
  void send_changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password);
  void recv_changeLocalUserPassword();
  void createLocalUser(const std::string& login, const std::string& user, const std::string& password);
  void send_createLocalUser(const std::string& login, const std::string& user, const std::string& password);
  void recv_createLocalUser();
  void dropLocalUser(const std::string& login, const std::string& user);
  void send_dropLocalUser(const std::string& login, const std::string& user);
  void recv_dropLocalUser();
  void getUserAuthorizations(std::vector<std::string> & _return, const std::string& login, const std::string& user);
  void send_getUserAuthorizations(const std::string& login, const std::string& user);
  void recv_getUserAuthorizations(std::vector<std::string> & _return);
  void grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  void send_grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  void recv_grantSystemPermission();
  void grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  void send_grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  void recv_grantTablePermission();
  bool hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  void send_hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  bool recv_hasSystemPermission();
  bool hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  void send_hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  bool recv_hasTablePermission();
  void listLocalUsers(std::set<std::string> & _return, const std::string& login);
  void send_listLocalUsers(const std::string& login);
  void recv_listLocalUsers(std::set<std::string> & _return);
  void revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  void send_revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm);
  void recv_revokeSystemPermission();
  void revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  void send_revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm);
  void recv_revokeTablePermission();
  void createBatchScanner(std::string& _return, const std::string& login, const std::string& tableName, const BatchScanOptions& options);
  void send_createBatchScanner(const std::string& login, const std::string& tableName, const BatchScanOptions& options);
  void recv_createBatchScanner(std::string& _return);
  void createScanner(std::string& _return, const std::string& login, const std::string& tableName, const ScanOptions& options);
  void send_createScanner(const std::string& login, const std::string& tableName, const ScanOptions& options);
  void recv_createScanner(std::string& _return);
  bool hasNext(const std::string& scanner);
  void send_hasNext(const std::string& scanner);
  bool recv_hasNext();
  void nextEntry(KeyValueAndPeek& _return, const std::string& scanner);
  void send_nextEntry(const std::string& scanner);
  void recv_nextEntry(KeyValueAndPeek& _return);
  void nextK(ScanResult& _return, const std::string& scanner, const int32_t k);
  void send_nextK(const std::string& scanner, const int32_t k);
  void recv_nextK(ScanResult& _return);
  void closeScanner(const std::string& scanner);
  void send_closeScanner(const std::string& scanner);
  void recv_closeScanner();
  void updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells);
  void send_updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells);
  void recv_updateAndFlush();
  void createWriter(std::string& _return, const std::string& login, const std::string& tableName, const WriterOptions& opts);
  void send_createWriter(const std::string& login, const std::string& tableName, const WriterOptions& opts);
  void recv_createWriter(std::string& _return);
  void update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells);
  void send_update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells);
  void flush(const std::string& writer);
  void send_flush(const std::string& writer);
  void recv_flush();
  void closeWriter(const std::string& writer);
  void send_closeWriter(const std::string& writer);
  void recv_closeWriter();
  ConditionalStatus::type updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates);
  void send_updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates);
  ConditionalStatus::type recv_updateRowConditionally();
  void createConditionalWriter(std::string& _return, const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options);
  void send_createConditionalWriter(const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options);
  void recv_createConditionalWriter(std::string& _return);
  void updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return, const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates);
  void send_updateRowsConditionally(const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates);
  void recv_updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return);
  void closeConditionalWriter(const std::string& conditionalWriter);
  void send_closeConditionalWriter(const std::string& conditionalWriter);
  void recv_closeConditionalWriter();
  void getRowRange(Range& _return, const std::string& row);
  void send_getRowRange(const std::string& row);
  void recv_getRowRange(Range& _return);
  void getFollowing(Key& _return, const Key& key, const PartialKey::type part);
  void send_getFollowing(const Key& key, const PartialKey::type part);
  void recv_getFollowing(Key& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class AccumuloProxyProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<AccumuloProxyIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (AccumuloProxyProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_login(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addConstraint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addSplits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_attachIterator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkIteratorConflicts(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_clearLocatorCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cloneTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compactTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancelCompaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exportTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flushTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDiskUsage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLocalityGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getIteratorSetting(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getMaxRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableProperties(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_importDirectory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_importTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listSplits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listTables(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listIterators(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listConstraints(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mergeTablets(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_offlineTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_onlineTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeConstraint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeIterator(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeTableProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_renameTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setLocalityGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setTableProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_splitRangeByTablets(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tableExists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tableIdMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testTableClassLoad(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pingTabletServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getActiveScans(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getActiveCompactions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getSiteConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getSystemConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTabletServers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setProperty(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testClassLoad(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_authenticateUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_changeUserAuthorizations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_changeLocalUserPassword(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createLocalUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_dropLocalUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUserAuthorizations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_grantSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_grantTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hasSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hasTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_listLocalUsers(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_revokeSystemPermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_revokeTablePermission(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createBatchScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hasNext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_nextEntry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_nextK(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeScanner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateAndFlush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flush(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateRowConditionally(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createConditionalWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateRowsConditionally(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeConditionalWriter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowRange(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFollowing(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  AccumuloProxyProcessor(boost::shared_ptr<AccumuloProxyIf> iface) :
    iface_(iface) {
    processMap_["login"] = &AccumuloProxyProcessor::process_login;
    processMap_["addConstraint"] = &AccumuloProxyProcessor::process_addConstraint;
    processMap_["addSplits"] = &AccumuloProxyProcessor::process_addSplits;
    processMap_["attachIterator"] = &AccumuloProxyProcessor::process_attachIterator;
    processMap_["checkIteratorConflicts"] = &AccumuloProxyProcessor::process_checkIteratorConflicts;
    processMap_["clearLocatorCache"] = &AccumuloProxyProcessor::process_clearLocatorCache;
    processMap_["cloneTable"] = &AccumuloProxyProcessor::process_cloneTable;
    processMap_["compactTable"] = &AccumuloProxyProcessor::process_compactTable;
    processMap_["cancelCompaction"] = &AccumuloProxyProcessor::process_cancelCompaction;
    processMap_["createTable"] = &AccumuloProxyProcessor::process_createTable;
    processMap_["deleteTable"] = &AccumuloProxyProcessor::process_deleteTable;
    processMap_["deleteRows"] = &AccumuloProxyProcessor::process_deleteRows;
    processMap_["exportTable"] = &AccumuloProxyProcessor::process_exportTable;
    processMap_["flushTable"] = &AccumuloProxyProcessor::process_flushTable;
    processMap_["getDiskUsage"] = &AccumuloProxyProcessor::process_getDiskUsage;
    processMap_["getLocalityGroups"] = &AccumuloProxyProcessor::process_getLocalityGroups;
    processMap_["getIteratorSetting"] = &AccumuloProxyProcessor::process_getIteratorSetting;
    processMap_["getMaxRow"] = &AccumuloProxyProcessor::process_getMaxRow;
    processMap_["getTableProperties"] = &AccumuloProxyProcessor::process_getTableProperties;
    processMap_["importDirectory"] = &AccumuloProxyProcessor::process_importDirectory;
    processMap_["importTable"] = &AccumuloProxyProcessor::process_importTable;
    processMap_["listSplits"] = &AccumuloProxyProcessor::process_listSplits;
    processMap_["listTables"] = &AccumuloProxyProcessor::process_listTables;
    processMap_["listIterators"] = &AccumuloProxyProcessor::process_listIterators;
    processMap_["listConstraints"] = &AccumuloProxyProcessor::process_listConstraints;
    processMap_["mergeTablets"] = &AccumuloProxyProcessor::process_mergeTablets;
    processMap_["offlineTable"] = &AccumuloProxyProcessor::process_offlineTable;
    processMap_["onlineTable"] = &AccumuloProxyProcessor::process_onlineTable;
    processMap_["removeConstraint"] = &AccumuloProxyProcessor::process_removeConstraint;
    processMap_["removeIterator"] = &AccumuloProxyProcessor::process_removeIterator;
    processMap_["removeTableProperty"] = &AccumuloProxyProcessor::process_removeTableProperty;
    processMap_["renameTable"] = &AccumuloProxyProcessor::process_renameTable;
    processMap_["setLocalityGroups"] = &AccumuloProxyProcessor::process_setLocalityGroups;
    processMap_["setTableProperty"] = &AccumuloProxyProcessor::process_setTableProperty;
    processMap_["splitRangeByTablets"] = &AccumuloProxyProcessor::process_splitRangeByTablets;
    processMap_["tableExists"] = &AccumuloProxyProcessor::process_tableExists;
    processMap_["tableIdMap"] = &AccumuloProxyProcessor::process_tableIdMap;
    processMap_["testTableClassLoad"] = &AccumuloProxyProcessor::process_testTableClassLoad;
    processMap_["pingTabletServer"] = &AccumuloProxyProcessor::process_pingTabletServer;
    processMap_["getActiveScans"] = &AccumuloProxyProcessor::process_getActiveScans;
    processMap_["getActiveCompactions"] = &AccumuloProxyProcessor::process_getActiveCompactions;
    processMap_["getSiteConfiguration"] = &AccumuloProxyProcessor::process_getSiteConfiguration;
    processMap_["getSystemConfiguration"] = &AccumuloProxyProcessor::process_getSystemConfiguration;
    processMap_["getTabletServers"] = &AccumuloProxyProcessor::process_getTabletServers;
    processMap_["removeProperty"] = &AccumuloProxyProcessor::process_removeProperty;
    processMap_["setProperty"] = &AccumuloProxyProcessor::process_setProperty;
    processMap_["testClassLoad"] = &AccumuloProxyProcessor::process_testClassLoad;
    processMap_["authenticateUser"] = &AccumuloProxyProcessor::process_authenticateUser;
    processMap_["changeUserAuthorizations"] = &AccumuloProxyProcessor::process_changeUserAuthorizations;
    processMap_["changeLocalUserPassword"] = &AccumuloProxyProcessor::process_changeLocalUserPassword;
    processMap_["createLocalUser"] = &AccumuloProxyProcessor::process_createLocalUser;
    processMap_["dropLocalUser"] = &AccumuloProxyProcessor::process_dropLocalUser;
    processMap_["getUserAuthorizations"] = &AccumuloProxyProcessor::process_getUserAuthorizations;
    processMap_["grantSystemPermission"] = &AccumuloProxyProcessor::process_grantSystemPermission;
    processMap_["grantTablePermission"] = &AccumuloProxyProcessor::process_grantTablePermission;
    processMap_["hasSystemPermission"] = &AccumuloProxyProcessor::process_hasSystemPermission;
    processMap_["hasTablePermission"] = &AccumuloProxyProcessor::process_hasTablePermission;
    processMap_["listLocalUsers"] = &AccumuloProxyProcessor::process_listLocalUsers;
    processMap_["revokeSystemPermission"] = &AccumuloProxyProcessor::process_revokeSystemPermission;
    processMap_["revokeTablePermission"] = &AccumuloProxyProcessor::process_revokeTablePermission;
    processMap_["createBatchScanner"] = &AccumuloProxyProcessor::process_createBatchScanner;
    processMap_["createScanner"] = &AccumuloProxyProcessor::process_createScanner;
    processMap_["hasNext"] = &AccumuloProxyProcessor::process_hasNext;
    processMap_["nextEntry"] = &AccumuloProxyProcessor::process_nextEntry;
    processMap_["nextK"] = &AccumuloProxyProcessor::process_nextK;
    processMap_["closeScanner"] = &AccumuloProxyProcessor::process_closeScanner;
    processMap_["updateAndFlush"] = &AccumuloProxyProcessor::process_updateAndFlush;
    processMap_["createWriter"] = &AccumuloProxyProcessor::process_createWriter;
    processMap_["update"] = &AccumuloProxyProcessor::process_update;
    processMap_["flush"] = &AccumuloProxyProcessor::process_flush;
    processMap_["closeWriter"] = &AccumuloProxyProcessor::process_closeWriter;
    processMap_["updateRowConditionally"] = &AccumuloProxyProcessor::process_updateRowConditionally;
    processMap_["createConditionalWriter"] = &AccumuloProxyProcessor::process_createConditionalWriter;
    processMap_["updateRowsConditionally"] = &AccumuloProxyProcessor::process_updateRowsConditionally;
    processMap_["closeConditionalWriter"] = &AccumuloProxyProcessor::process_closeConditionalWriter;
    processMap_["getRowRange"] = &AccumuloProxyProcessor::process_getRowRange;
    processMap_["getFollowing"] = &AccumuloProxyProcessor::process_getFollowing;
  }

  virtual ~AccumuloProxyProcessor() {}
};

class AccumuloProxyProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  AccumuloProxyProcessorFactory(const ::boost::shared_ptr< AccumuloProxyIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< AccumuloProxyIfFactory > handlerFactory_;
};

class AccumuloProxyMultiface : virtual public AccumuloProxyIf {
 public:
  AccumuloProxyMultiface(std::vector<boost::shared_ptr<AccumuloProxyIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~AccumuloProxyMultiface() {}
 protected:
  std::vector<boost::shared_ptr<AccumuloProxyIf> > ifaces_;
  AccumuloProxyMultiface() {}
  void add(boost::shared_ptr<AccumuloProxyIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void login(std::string& _return, const std::string& principal, const std::map<std::string, std::string> & loginProperties) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->login(_return, principal, loginProperties);
    }
    ifaces_[i]->login(_return, principal, loginProperties);
    return;
  }

  int32_t addConstraint(const std::string& login, const std::string& tableName, const std::string& constraintClassName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addConstraint(login, tableName, constraintClassName);
    }
    return ifaces_[i]->addConstraint(login, tableName, constraintClassName);
  }

  void addSplits(const std::string& login, const std::string& tableName, const std::set<std::string> & splits) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addSplits(login, tableName, splits);
    }
    ifaces_[i]->addSplits(login, tableName, splits);
  }

  void attachIterator(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->attachIterator(login, tableName, setting, scopes);
    }
    ifaces_[i]->attachIterator(login, tableName, setting, scopes);
  }

  void checkIteratorConflicts(const std::string& login, const std::string& tableName, const IteratorSetting& setting, const std::set<IteratorScope::type> & scopes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkIteratorConflicts(login, tableName, setting, scopes);
    }
    ifaces_[i]->checkIteratorConflicts(login, tableName, setting, scopes);
  }

  void clearLocatorCache(const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->clearLocatorCache(login, tableName);
    }
    ifaces_[i]->clearLocatorCache(login, tableName);
  }

  void cloneTable(const std::string& login, const std::string& tableName, const std::string& newTableName, const bool flush, const std::map<std::string, std::string> & propertiesToSet, const std::set<std::string> & propertiesToExclude) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude);
    }
    ifaces_[i]->cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude);
  }

  void compactTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const std::vector<IteratorSetting> & iterators, const bool flush, const bool wait) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->compactTable(login, tableName, startRow, endRow, iterators, flush, wait);
    }
    ifaces_[i]->compactTable(login, tableName, startRow, endRow, iterators, flush, wait);
  }

  void cancelCompaction(const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancelCompaction(login, tableName);
    }
    ifaces_[i]->cancelCompaction(login, tableName);
  }

  void createTable(const std::string& login, const std::string& tableName, const bool versioningIter, const TimeType::type type) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createTable(login, tableName, versioningIter, type);
    }
    ifaces_[i]->createTable(login, tableName, versioningIter, type);
  }

  void deleteTable(const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteTable(login, tableName);
    }
    ifaces_[i]->deleteTable(login, tableName);
  }

  void deleteRows(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteRows(login, tableName, startRow, endRow);
    }
    ifaces_[i]->deleteRows(login, tableName, startRow, endRow);
  }

  void exportTable(const std::string& login, const std::string& tableName, const std::string& exportDir) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exportTable(login, tableName, exportDir);
    }
    ifaces_[i]->exportTable(login, tableName, exportDir);
  }

  void flushTable(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow, const bool wait) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->flushTable(login, tableName, startRow, endRow, wait);
    }
    ifaces_[i]->flushTable(login, tableName, startRow, endRow, wait);
  }

  void getDiskUsage(std::vector<DiskUsage> & _return, const std::string& login, const std::set<std::string> & tables) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDiskUsage(_return, login, tables);
    }
    ifaces_[i]->getDiskUsage(_return, login, tables);
    return;
  }

  void getLocalityGroups(std::map<std::string, std::set<std::string> > & _return, const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLocalityGroups(_return, login, tableName);
    }
    ifaces_[i]->getLocalityGroups(_return, login, tableName);
    return;
  }

  void getIteratorSetting(IteratorSetting& _return, const std::string& login, const std::string& tableName, const std::string& iteratorName, const IteratorScope::type scope) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getIteratorSetting(_return, login, tableName, iteratorName, scope);
    }
    ifaces_[i]->getIteratorSetting(_return, login, tableName, iteratorName, scope);
    return;
  }

  void getMaxRow(std::string& _return, const std::string& login, const std::string& tableName, const std::set<std::string> & auths, const std::string& startRow, const bool startInclusive, const std::string& endRow, const bool endInclusive) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getMaxRow(_return, login, tableName, auths, startRow, startInclusive, endRow, endInclusive);
    }
    ifaces_[i]->getMaxRow(_return, login, tableName, auths, startRow, startInclusive, endRow, endInclusive);
    return;
  }

  void getTableProperties(std::map<std::string, std::string> & _return, const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTableProperties(_return, login, tableName);
    }
    ifaces_[i]->getTableProperties(_return, login, tableName);
    return;
  }

  void importDirectory(const std::string& login, const std::string& tableName, const std::string& importDir, const std::string& failureDir, const bool setTime) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->importDirectory(login, tableName, importDir, failureDir, setTime);
    }
    ifaces_[i]->importDirectory(login, tableName, importDir, failureDir, setTime);
  }

  void importTable(const std::string& login, const std::string& tableName, const std::string& importDir) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->importTable(login, tableName, importDir);
    }
    ifaces_[i]->importTable(login, tableName, importDir);
  }

  void listSplits(std::vector<std::string> & _return, const std::string& login, const std::string& tableName, const int32_t maxSplits) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listSplits(_return, login, tableName, maxSplits);
    }
    ifaces_[i]->listSplits(_return, login, tableName, maxSplits);
    return;
  }

  void listTables(std::set<std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listTables(_return, login);
    }
    ifaces_[i]->listTables(_return, login);
    return;
  }

  void listIterators(std::map<std::string, std::set<IteratorScope::type> > & _return, const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listIterators(_return, login, tableName);
    }
    ifaces_[i]->listIterators(_return, login, tableName);
    return;
  }

  void listConstraints(std::map<std::string, int32_t> & _return, const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listConstraints(_return, login, tableName);
    }
    ifaces_[i]->listConstraints(_return, login, tableName);
    return;
  }

  void mergeTablets(const std::string& login, const std::string& tableName, const std::string& startRow, const std::string& endRow) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mergeTablets(login, tableName, startRow, endRow);
    }
    ifaces_[i]->mergeTablets(login, tableName, startRow, endRow);
  }

  void offlineTable(const std::string& login, const std::string& tableName, const bool wait) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->offlineTable(login, tableName, wait);
    }
    ifaces_[i]->offlineTable(login, tableName, wait);
  }

  void onlineTable(const std::string& login, const std::string& tableName, const bool wait) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->onlineTable(login, tableName, wait);
    }
    ifaces_[i]->onlineTable(login, tableName, wait);
  }

  void removeConstraint(const std::string& login, const std::string& tableName, const int32_t constraint) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeConstraint(login, tableName, constraint);
    }
    ifaces_[i]->removeConstraint(login, tableName, constraint);
  }

  void removeIterator(const std::string& login, const std::string& tableName, const std::string& iterName, const std::set<IteratorScope::type> & scopes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeIterator(login, tableName, iterName, scopes);
    }
    ifaces_[i]->removeIterator(login, tableName, iterName, scopes);
  }

  void removeTableProperty(const std::string& login, const std::string& tableName, const std::string& property) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeTableProperty(login, tableName, property);
    }
    ifaces_[i]->removeTableProperty(login, tableName, property);
  }

  void renameTable(const std::string& login, const std::string& oldTableName, const std::string& newTableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->renameTable(login, oldTableName, newTableName);
    }
    ifaces_[i]->renameTable(login, oldTableName, newTableName);
  }

  void setLocalityGroups(const std::string& login, const std::string& tableName, const std::map<std::string, std::set<std::string> > & groups) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setLocalityGroups(login, tableName, groups);
    }
    ifaces_[i]->setLocalityGroups(login, tableName, groups);
  }

  void setTableProperty(const std::string& login, const std::string& tableName, const std::string& property, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setTableProperty(login, tableName, property, value);
    }
    ifaces_[i]->setTableProperty(login, tableName, property, value);
  }

  void splitRangeByTablets(std::set<Range> & _return, const std::string& login, const std::string& tableName, const Range& range, const int32_t maxSplits) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->splitRangeByTablets(_return, login, tableName, range, maxSplits);
    }
    ifaces_[i]->splitRangeByTablets(_return, login, tableName, range, maxSplits);
    return;
  }

  bool tableExists(const std::string& login, const std::string& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tableExists(login, tableName);
    }
    return ifaces_[i]->tableExists(login, tableName);
  }

  void tableIdMap(std::map<std::string, std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tableIdMap(_return, login);
    }
    ifaces_[i]->tableIdMap(_return, login);
    return;
  }

  bool testTableClassLoad(const std::string& login, const std::string& tableName, const std::string& className, const std::string& asTypeName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testTableClassLoad(login, tableName, className, asTypeName);
    }
    return ifaces_[i]->testTableClassLoad(login, tableName, className, asTypeName);
  }

  void pingTabletServer(const std::string& login, const std::string& tserver) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pingTabletServer(login, tserver);
    }
    ifaces_[i]->pingTabletServer(login, tserver);
  }

  void getActiveScans(std::vector<ActiveScan> & _return, const std::string& login, const std::string& tserver) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getActiveScans(_return, login, tserver);
    }
    ifaces_[i]->getActiveScans(_return, login, tserver);
    return;
  }

  void getActiveCompactions(std::vector<ActiveCompaction> & _return, const std::string& login, const std::string& tserver) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getActiveCompactions(_return, login, tserver);
    }
    ifaces_[i]->getActiveCompactions(_return, login, tserver);
    return;
  }

  void getSiteConfiguration(std::map<std::string, std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSiteConfiguration(_return, login);
    }
    ifaces_[i]->getSiteConfiguration(_return, login);
    return;
  }

  void getSystemConfiguration(std::map<std::string, std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSystemConfiguration(_return, login);
    }
    ifaces_[i]->getSystemConfiguration(_return, login);
    return;
  }

  void getTabletServers(std::vector<std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTabletServers(_return, login);
    }
    ifaces_[i]->getTabletServers(_return, login);
    return;
  }

  void removeProperty(const std::string& login, const std::string& property) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeProperty(login, property);
    }
    ifaces_[i]->removeProperty(login, property);
  }

  void setProperty(const std::string& login, const std::string& property, const std::string& value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setProperty(login, property, value);
    }
    ifaces_[i]->setProperty(login, property, value);
  }

  bool testClassLoad(const std::string& login, const std::string& className, const std::string& asTypeName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testClassLoad(login, className, asTypeName);
    }
    return ifaces_[i]->testClassLoad(login, className, asTypeName);
  }

  bool authenticateUser(const std::string& login, const std::string& user, const std::map<std::string, std::string> & properties) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticateUser(login, user, properties);
    }
    return ifaces_[i]->authenticateUser(login, user, properties);
  }

  void changeUserAuthorizations(const std::string& login, const std::string& user, const std::set<std::string> & authorizations) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->changeUserAuthorizations(login, user, authorizations);
    }
    ifaces_[i]->changeUserAuthorizations(login, user, authorizations);
  }

  void changeLocalUserPassword(const std::string& login, const std::string& user, const std::string& password) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->changeLocalUserPassword(login, user, password);
    }
    ifaces_[i]->changeLocalUserPassword(login, user, password);
  }

  void createLocalUser(const std::string& login, const std::string& user, const std::string& password) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createLocalUser(login, user, password);
    }
    ifaces_[i]->createLocalUser(login, user, password);
  }

  void dropLocalUser(const std::string& login, const std::string& user) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->dropLocalUser(login, user);
    }
    ifaces_[i]->dropLocalUser(login, user);
  }

  void getUserAuthorizations(std::vector<std::string> & _return, const std::string& login, const std::string& user) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getUserAuthorizations(_return, login, user);
    }
    ifaces_[i]->getUserAuthorizations(_return, login, user);
    return;
  }

  void grantSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->grantSystemPermission(login, user, perm);
    }
    ifaces_[i]->grantSystemPermission(login, user, perm);
  }

  void grantTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->grantTablePermission(login, user, table, perm);
    }
    ifaces_[i]->grantTablePermission(login, user, table, perm);
  }

  bool hasSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hasSystemPermission(login, user, perm);
    }
    return ifaces_[i]->hasSystemPermission(login, user, perm);
  }

  bool hasTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hasTablePermission(login, user, table, perm);
    }
    return ifaces_[i]->hasTablePermission(login, user, table, perm);
  }

  void listLocalUsers(std::set<std::string> & _return, const std::string& login) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->listLocalUsers(_return, login);
    }
    ifaces_[i]->listLocalUsers(_return, login);
    return;
  }

  void revokeSystemPermission(const std::string& login, const std::string& user, const SystemPermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->revokeSystemPermission(login, user, perm);
    }
    ifaces_[i]->revokeSystemPermission(login, user, perm);
  }

  void revokeTablePermission(const std::string& login, const std::string& user, const std::string& table, const TablePermission::type perm) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->revokeTablePermission(login, user, table, perm);
    }
    ifaces_[i]->revokeTablePermission(login, user, table, perm);
  }

  void createBatchScanner(std::string& _return, const std::string& login, const std::string& tableName, const BatchScanOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createBatchScanner(_return, login, tableName, options);
    }
    ifaces_[i]->createBatchScanner(_return, login, tableName, options);
    return;
  }

  void createScanner(std::string& _return, const std::string& login, const std::string& tableName, const ScanOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createScanner(_return, login, tableName, options);
    }
    ifaces_[i]->createScanner(_return, login, tableName, options);
    return;
  }

  bool hasNext(const std::string& scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hasNext(scanner);
    }
    return ifaces_[i]->hasNext(scanner);
  }

  void nextEntry(KeyValueAndPeek& _return, const std::string& scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->nextEntry(_return, scanner);
    }
    ifaces_[i]->nextEntry(_return, scanner);
    return;
  }

  void nextK(ScanResult& _return, const std::string& scanner, const int32_t k) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->nextK(_return, scanner, k);
    }
    ifaces_[i]->nextK(_return, scanner, k);
    return;
  }

  void closeScanner(const std::string& scanner) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeScanner(scanner);
    }
    ifaces_[i]->closeScanner(scanner);
  }

  void updateAndFlush(const std::string& login, const std::string& tableName, const std::map<std::string, std::vector<ColumnUpdate> > & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateAndFlush(login, tableName, cells);
    }
    ifaces_[i]->updateAndFlush(login, tableName, cells);
  }

  void createWriter(std::string& _return, const std::string& login, const std::string& tableName, const WriterOptions& opts) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createWriter(_return, login, tableName, opts);
    }
    ifaces_[i]->createWriter(_return, login, tableName, opts);
    return;
  }

  void update(const std::string& writer, const std::map<std::string, std::vector<ColumnUpdate> > & cells) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->update(writer, cells);
    }
    ifaces_[i]->update(writer, cells);
  }

  void flush(const std::string& writer) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->flush(writer);
    }
    ifaces_[i]->flush(writer);
  }

  void closeWriter(const std::string& writer) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeWriter(writer);
    }
    ifaces_[i]->closeWriter(writer);
  }

  ConditionalStatus::type updateRowConditionally(const std::string& login, const std::string& tableName, const std::string& row, const ConditionalUpdates& updates) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateRowConditionally(login, tableName, row, updates);
    }
    return ifaces_[i]->updateRowConditionally(login, tableName, row, updates);
  }

  void createConditionalWriter(std::string& _return, const std::string& login, const std::string& tableName, const ConditionalWriterOptions& options) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createConditionalWriter(_return, login, tableName, options);
    }
    ifaces_[i]->createConditionalWriter(_return, login, tableName, options);
    return;
  }

  void updateRowsConditionally(std::map<std::string, ConditionalStatus::type> & _return, const std::string& conditionalWriter, const std::map<std::string, ConditionalUpdates> & updates) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateRowsConditionally(_return, conditionalWriter, updates);
    }
    ifaces_[i]->updateRowsConditionally(_return, conditionalWriter, updates);
    return;
  }

  void closeConditionalWriter(const std::string& conditionalWriter) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeConditionalWriter(conditionalWriter);
    }
    ifaces_[i]->closeConditionalWriter(conditionalWriter);
  }

  void getRowRange(Range& _return, const std::string& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowRange(_return, row);
    }
    ifaces_[i]->getRowRange(_return, row);
    return;
  }

  void getFollowing(Key& _return, const Key& key, const PartialKey::type part) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getFollowing(_return, key, part);
    }
    ifaces_[i]->getFollowing(_return, key, part);
    return;
  }

};

} // namespace

#endif

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "proxy_types.h"

#include <algorithm>

namespace accumulo {

int _kPartialKeyValues[] = {
  PartialKey::ROW,
  PartialKey::ROW_COLFAM,
  PartialKey::ROW_COLFAM_COLQUAL,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS_TIME,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL
};
const char* _kPartialKeyNames[] = {
  "ROW",
  "ROW_COLFAM",
  "ROW_COLFAM_COLQUAL",
  "ROW_COLFAM_COLQUAL_COLVIS",
  "ROW_COLFAM_COLQUAL_COLVIS_TIME",
  "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL"
};
const std::map<int, const char*> _PartialKey_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kPartialKeyValues, _kPartialKeyNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTablePermissionValues[] = {
  TablePermission::READ,
  TablePermission::WRITE,
  TablePermission::BULK_IMPORT,
  TablePermission::ALTER_TABLE,
  TablePermission::GRANT,
  TablePermission::DROP_TABLE
};
const char* _kTablePermissionNames[] = {
  "READ",
  "WRITE",
  "BULK_IMPORT",
  "ALTER_TABLE",
  "GRANT",
  "DROP_TABLE"
};
const std::map<int, const char*> _TablePermission_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTablePermissionValues, _kTablePermissionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSystemPermissionValues[] = {
  SystemPermission::GRANT,
  SystemPermission::CREATE_TABLE,
  SystemPermission::DROP_TABLE,
  SystemPermission::ALTER_TABLE,
  SystemPermission::CREATE_USER,
  SystemPermission::DROP_USER,
  SystemPermission::ALTER_USER,
  SystemPermission::SYSTEM
};
const char* _kSystemPermissionNames[] = {
  "GRANT",
  "CREATE_TABLE",
  "DROP_TABLE",
  "ALTER_TABLE",
  "CREATE_USER",
  "DROP_USER",
  "ALTER_USER",
  "SYSTEM"
};
const std::map<int, const char*> _SystemPermission_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kSystemPermissionValues, _kSystemPermissionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kScanTypeValues[] = {
  ScanType::SINGLE,
  ScanType::BATCH
};
const char* _kScanTypeNames[] = {
  "SINGLE",
  "BATCH"
};
const std::map<int, const char*> _ScanType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kScanTypeValues, _kScanTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kScanStateValues[] = {
  ScanState::IDLE,
  ScanState::RUNNING,
  ScanState::QUEUED
};
const char* _kScanStateNames[] = {
  "IDLE",
  "RUNNING",
  "QUEUED"
};
const std::map<int, const char*> _ScanState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kScanStateValues, _kScanStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MERGE,
  CompactionType::MAJOR,
  CompactionType::FULL
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MERGE",
  "MAJOR",
  "FULL"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompactionReasonValues[] = {
  CompactionReason::USER,
  CompactionReason::SYSTEM,
  CompactionReason::CHOP,
  CompactionReason::IDLE,
  CompactionReason::CLOSE
};
const char* _kCompactionReasonNames[] = {
  "USER",
  "SYSTEM",
  "CHOP",
  "IDLE",
  "CLOSE"
};
const std::map<int, const char*> _CompactionReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCompactionReasonValues, _kCompactionReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIteratorScopeValues[] = {
  IteratorScope::MINC,
  IteratorScope::MAJC,
  IteratorScope::SCAN
};
const char* _kIteratorScopeNames[] = {
  "MINC",
  "MAJC",
  "SCAN"
};
const std::map<int, const char*> _IteratorScope_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIteratorScopeValues, _kIteratorScopeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTimeTypeValues[] = {
  TimeType::LOGICAL,
  TimeType::MILLIS
};
const char* _kTimeTypeNames[] = {
  "LOGICAL",
  "MILLIS"
};
const std::map<int, const char*> _TimeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTimeTypeValues, _kTimeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Key::ascii_fingerprint = "91151A432E03F5E8564877B5194B48E2";
const uint8_t Key::binary_fingerprint[16] = {0x91,0x15,0x1A,0x43,0x2E,0x03,0xF5,0xE8,0x56,0x48,0x77,0xB5,0x19,0x4B,0x48,0xE2};

uint32_t Key::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Key::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Key");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->colVisibility);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Key &a, Key &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

const char* ColumnUpdate::ascii_fingerprint = "65CC1863F7DDC1DE75B9EAF9E2DC0D1F";
const uint8_t ColumnUpdate::binary_fingerprint[16] = {0x65,0xCC,0x18,0x63,0xF7,0xDD,0xC1,0xDE,0x75,0xB9,0xEA,0xF9,0xE2,0xDC,0x0D,0x1F};

uint32_t ColumnUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteCell);
          this->__isset.deleteCell = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnUpdate");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.colVisibility) {
    xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->colVisibility);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteCell) {
    xfer += oprot->writeFieldBegin("deleteCell", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->deleteCell);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnUpdate &a, ColumnUpdate &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.timestamp, b.timestamp);
  swap(a.value, b.value);
  swap(a.deleteCell, b.deleteCell);
  swap(a.__isset, b.__isset);
}

const char* KeyValue::ascii_fingerprint = "0D0CA44F233F983E00E94228C31ABBD4";
const uint8_t KeyValue::binary_fingerprint[16] = {0x0D,0x0C,0xA4,0x4F,0x23,0x3F,0x98,0x3E,0x00,0xE9,0x42,0x28,0xC3,0x1A,0xBB,0xD4};

uint32_t KeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyValue");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyValue &a, KeyValue &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* ScanResult::ascii_fingerprint = "684A3FCA76EA202FE071A17F8B510E7A";
const uint8_t ScanResult::binary_fingerprint[16] = {0x68,0x4A,0x3F,0xCA,0x76,0xEA,0x20,0x2F,0xE0,0x71,0xA1,0x7F,0x8B,0x51,0x0E,0x7A};

uint32_t ScanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->results.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->results[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->more);
          this->__isset.more = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ScanResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<KeyValue> ::const_iterator _iter5;
    for (_iter5 = this->results.begin(); _iter5 != this->results.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->more);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanResult &a, ScanResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
  swap(a.more, b.more);
  swap(a.__isset, b.__isset);
}

const char* Range::ascii_fingerprint = "84C5BA8DB718E60BFBF3F83867647B45";
const uint8_t Range::binary_fingerprint[16] = {0x84,0xC5,0xBA,0x8D,0xB7,0x18,0xE6,0x0B,0xFB,0xF3,0xF8,0x38,0x67,0x64,0x7B,0x45};

uint32_t Range::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startInclusive);
          this->__isset.startInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stop.read(iprot);
          this->__isset.stop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->stopInclusive);
          this->__isset.stopInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Range");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startInclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stop", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopInclusive", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->stopInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Range &a, Range &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.startInclusive, b.startInclusive);
  swap(a.stop, b.stop);
  swap(a.stopInclusive, b.stopInclusive);
  swap(a.__isset, b.__isset);
}

const char* ScanColumn::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t ScanColumn::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t ScanColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ScanColumn");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.colQualifier) {
    xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->colQualifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanColumn &a, ScanColumn &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.__isset, b.__isset);
}

const char* IteratorSetting::ascii_fingerprint = "985C857916964E43205EAC92A157CB4E";
const uint8_t IteratorSetting::binary_fingerprint[16] = {0x98,0x5C,0x85,0x79,0x16,0x96,0x4E,0x43,0x20,0x5E,0xAC,0x92,0xA1,0x57,0xCB,0x4E};

uint32_t IteratorSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iteratorClass);
          this->__isset.iteratorClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::string& _val12 = this->properties[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IteratorSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IteratorSetting");

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iteratorClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iteratorClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter13;
    for (_iter13 = this->properties.begin(); _iter13 != this->properties.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IteratorSetting &a, IteratorSetting &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.name, b.name);
  swap(a.iteratorClass, b.iteratorClass);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

const char* ScanOptions::ascii_fingerprint = "3D87D0CD05FA62E15880C4D2C595907C";
const uint8_t ScanOptions::binary_fingerprint[16] = {0x3D,0x87,0xD0,0xCD,0x05,0xFA,0x62,0xE1,0x58,0x80,0xC4,0xD2,0xC5,0x95,0x90,0x7C};

uint32_t ScanOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readSetBegin(_etype17, _size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              std::string _elem19;
              xfer += iprot->readBinary(_elem19);
              this->authorizations.insert(_elem19);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range.read(iprot);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->columns.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->columns[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->iterators.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->iterators[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bufferSize);
          this->__isset.bufferSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ScanOptions");

  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
      std::set<std::string> ::const_iterator _iter30;
      for (_iter30 = this->authorizations.begin(); _iter30 != this->authorizations.end(); ++_iter30)
      {
        xfer += oprot->writeBinary((*_iter30));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range) {
    xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<ScanColumn> ::const_iterator _iter31;
      for (_iter31 = this->columns.begin(); _iter31 != this->columns.end(); ++_iter31)
      {
        xfer += (*_iter31).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iterators) {
    xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
      std::vector<IteratorSetting> ::const_iterator _iter32;
      for (_iter32 = this->iterators.begin(); _iter32 != this->iterators.end(); ++_iter32)
      {
        xfer += (*_iter32).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bufferSize) {
    xfer += oprot->writeFieldBegin("bufferSize", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->bufferSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanOptions &a, ScanOptions &b) {
  using ::std::swap;
  swap(a.authorizations, b.authorizations);
  swap(a.range, b.range);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.bufferSize, b.bufferSize);
  swap(a.__isset, b.__isset);
}

const char* BatchScanOptions::ascii_fingerprint = "6ADFA1FBE31B1220D2C103284E002308";
const uint8_t BatchScanOptions::binary_fingerprint[16] = {0x6A,0xDF,0xA1,0xFB,0xE3,0x1B,0x12,0x20,0xD2,0xC1,0x03,0x28,0x4E,0x00,0x23,0x08};

uint32_t BatchScanOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readSetBegin(_etype36, _size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              std::string _elem38;
              xfer += iprot->readBinary(_elem38);
              this->authorizations.insert(_elem38);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->ranges.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->ranges[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->columns.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += this->columns[_i48].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->iterators.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += this->iterators[_i53].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BatchScanOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BatchScanOptions");

  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
      std::set<std::string> ::const_iterator _iter54;
      for (_iter54 = this->authorizations.begin(); _iter54 != this->authorizations.end(); ++_iter54)
      {
        xfer += oprot->writeBinary((*_iter54));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ranges) {
    xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
      std::vector<Range> ::const_iterator _iter55;
      for (_iter55 = this->ranges.begin(); _iter55 != this->ranges.end(); ++_iter55)
      {
        xfer += (*_iter55).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<ScanColumn> ::const_iterator _iter56;
      for (_iter56 = this->columns.begin(); _iter56 != this->columns.end(); ++_iter56)
      {
        xfer += (*_iter56).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iterators) {
    xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
      std::vector<IteratorSetting> ::const_iterator _iter57;
      for (_iter57 = this->iterators.begin(); _iter57 != this->iterators.end(); ++_iter57)
      {
        xfer += (*_iter57).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.threads) {
    xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->threads);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BatchScanOptions &a, BatchScanOptions &b) {
  using ::std::swap;
  swap(a.authorizations, b.authorizations);
  swap(a.ranges, b.ranges);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.threads, b.threads);
  swap(a.__isset, b.__isset);
}

const char* KeyValueAndPeek::ascii_fingerprint = "CBBC6AB9C7EA5E5E748C13F970862FAB";
const uint8_t KeyValueAndPeek::binary_fingerprint[16] = {0xCB,0xBC,0x6A,0xB9,0xC7,0xEA,0x5E,0x5E,0x74,0x8C,0x13,0xF9,0x70,0x86,0x2F,0xAB};

uint32_t KeyValueAndPeek::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyValue.read(iprot);
          this->__isset.keyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasNext);
          this->__isset.hasNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyValueAndPeek::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyValueAndPeek");

  xfer += oprot->writeFieldBegin("keyValue", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->keyValue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasNext", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyValueAndPeek &a, KeyValueAndPeek &b) {
  using ::std::swap;
  swap(a.keyValue, b.keyValue);
  swap(a.hasNext, b.hasNext);
  swap(a.__isset, b.__isset);
}

const char* KeyExtent::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t KeyExtent::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t KeyExtent::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->prevEndRow);
          this->__isset.prevEndRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyExtent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyExtent");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevEndRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->prevEndRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyExtent &a, KeyExtent &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.endRow, b.endRow);
  swap(a.prevEndRow, b.prevEndRow);
  swap(a.__isset, b.__isset);
}

const char* Column::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t Column::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Column");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->colVisibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Column &a, Column &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.__isset, b.__isset);
}

const char* ActiveScan::ascii_fingerprint = "1B97541CB4E900A054266BBBEE61D004";
const uint8_t ActiveScan::binary_fingerprint[16] = {0x1B,0x97,0x54,0x1C,0xB4,0xE9,0x00,0xA0,0x54,0x26,0x6B,0xBB,0xEE,0x61,0xD0,0x04};

uint32_t ActiveScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client);
          this->__isset.client = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->idleTime);
          this->__isset.idleTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->type = (ScanType::type)ecast58;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast59;
          xfer += iprot->readI32(ecast59);
          this->state = (ScanState::type)ecast59;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->columns.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->columns[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->iterators.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->iterators[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->authorizations.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += iprot->readBinary(this->authorizations[_i74]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ActiveScan");

  xfer += oprot->writeFieldBegin("client", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->client);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idleTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->idleTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter75;
    for (_iter75 = this->columns.begin(); _iter75 != this->columns.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<IteratorSetting> ::const_iterator _iter76;
    for (_iter76 = this->iterators.begin(); _iter76 != this->iterators.end(); ++_iter76)
    {
      xfer += (*_iter76).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->authorizations.begin(); _iter77 != this->authorizations.end(); ++_iter77)
    {
      xfer += oprot->writeBinary((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveScan &a, ActiveScan &b) {
  using ::std::swap;
  swap(a.client, b.client);
  swap(a.user, b.user);
  swap(a.table, b.table);
  swap(a.age, b.age);
  swap(a.idleTime, b.idleTime);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.extent, b.extent);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.authorizations, b.authorizations);
  swap(a.__isset, b.__isset);
}

const char* ActiveCompaction::ascii_fingerprint = "2BB155CC901109464666B6C7E6A8C1A6";
const uint8_t ActiveCompaction::binary_fingerprint[16] = {0x2B,0xB1,0x55,0xCC,0x90,0x11,0x09,0x46,0x46,0x66,0xB6,0xC7,0xE6,0xA8,0xC1,0xA6};

uint32_t ActiveCompaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputFiles.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->inputFiles.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += iprot->readString(this->inputFiles[_i82]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFile);
          this->__isset.outputFile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast83;
          xfer += iprot->readI32(ecast83);
          this->type = (CompactionType::type)ecast83;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast84;
          xfer += iprot->readI32(ecast84);
          this->reason = (CompactionReason::type)ecast84;
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localityGroup);
          this->__isset.localityGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesRead);
          this->__isset.entriesRead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesWritten);
          this->__isset.entriesWritten = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->iterators.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->iterators[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveCompaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ActiveCompaction");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFiles", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->inputFiles.size()));
    std::vector<std::string> ::const_iterator _iter90;
    for (_iter90 = this->inputFiles.begin(); _iter90 != this->inputFiles.end(); ++_iter90)
    {
      xfer += oprot->writeString((*_iter90));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFile", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("localityGroup", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->localityGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesRead", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->entriesRead);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesWritten", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->entriesWritten);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<IteratorSetting> ::const_iterator _iter91;
    for (_iter91 = this->iterators.begin(); _iter91 != this->iterators.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveCompaction &a, ActiveCompaction &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.age, b.age);
  swap(a.inputFiles, b.inputFiles);
  swap(a.outputFile, b.outputFile);
  swap(a.type, b.type);
  swap(a.reason, b.reason);
  swap(a.localityGroup, b.localityGroup);
  swap(a.entriesRead, b.entriesRead);
  swap(a.entriesWritten, b.entriesWritten);
  swap(a.iterators, b.iterators);
  swap(a.__isset, b.__isset);
}

const char* WriterOptions::ascii_fingerprint = "D6FB71C9973666B9F6B5C20D5B7B19EF";
const uint8_t WriterOptions::binary_fingerprint[16] = {0xD6,0xFB,0x71,0xC9,0x97,0x36,0x66,0xB9,0xF6,0xB5,0xC2,0x0D,0x5B,0x7B,0x19,0xEF};

uint32_t WriterOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxMemory);
          this->__isset.maxMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latencyMs);
          this->__isset.latencyMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeoutMs);
          this->__isset.timeoutMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriterOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WriterOptions");

  xfer += oprot->writeFieldBegin("maxMemory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxMemory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latencyMs", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->latencyMs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeoutMs", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->timeoutMs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriterOptions &a, WriterOptions &b) {
  using ::std::swap;
  swap(a.maxMemory, b.maxMemory);
  swap(a.latencyMs, b.latencyMs);
  swap(a.timeoutMs, b.timeoutMs);
  swap(a.threads, b.threads);
  swap(a.__isset, b.__isset);
}

const char* UnknownScanner::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t UnknownScanner::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t UnknownScanner::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownScanner::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnknownScanner");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownScanner &a, UnknownScanner &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* UnknownWriter::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t UnknownWriter::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t UnknownWriter::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownWriter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnknownWriter");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownWriter &a, UnknownWriter &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* NoMoreEntriesException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t NoMoreEntriesException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t NoMoreEntriesException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoMoreEntriesException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NoMoreEntriesException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoMoreEntriesException &a, NoMoreEntriesException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* AccumuloException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AccumuloException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AccumuloException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccumuloException &a, AccumuloException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* AccumuloSecurityException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AccumuloSecurityException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AccumuloSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AccumuloSecurityException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccumuloSecurityException &a, AccumuloSecurityException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* TableNotFoundException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TableNotFoundException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TableNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableNotFoundException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableNotFoundException &a, TableNotFoundException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* TableExistsException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TableExistsException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TableExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TableExistsException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableExistsException &a, TableExistsException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* MutationsRejectedException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t MutationsRejectedException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t MutationsRejectedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MutationsRejectedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MutationsRejectedException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MutationsRejectedException &a, MutationsRejectedException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

} // namespace

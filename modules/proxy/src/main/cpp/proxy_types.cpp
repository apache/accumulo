/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "proxy_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace accumulo {

int _kPartialKeyValues[] = {
  PartialKey::ROW,
  PartialKey::ROW_COLFAM,
  PartialKey::ROW_COLFAM_COLQUAL,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS_TIME,
  PartialKey::ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL
};
const char* _kPartialKeyNames[] = {
  "ROW",
  "ROW_COLFAM",
  "ROW_COLFAM_COLQUAL",
  "ROW_COLFAM_COLQUAL_COLVIS",
  "ROW_COLFAM_COLQUAL_COLVIS_TIME",
  "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL"
};
const std::map<int, const char*> _PartialKey_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kPartialKeyValues, _kPartialKeyNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTablePermissionValues[] = {
  TablePermission::READ,
  TablePermission::WRITE,
  TablePermission::BULK_IMPORT,
  TablePermission::ALTER_TABLE,
  TablePermission::GRANT,
  TablePermission::DROP_TABLE
};
const char* _kTablePermissionNames[] = {
  "READ",
  "WRITE",
  "BULK_IMPORT",
  "ALTER_TABLE",
  "GRANT",
  "DROP_TABLE"
};
const std::map<int, const char*> _TablePermission_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTablePermissionValues, _kTablePermissionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSystemPermissionValues[] = {
  SystemPermission::GRANT,
  SystemPermission::CREATE_TABLE,
  SystemPermission::DROP_TABLE,
  SystemPermission::ALTER_TABLE,
  SystemPermission::CREATE_USER,
  SystemPermission::DROP_USER,
  SystemPermission::ALTER_USER,
  SystemPermission::SYSTEM,
  SystemPermission::CREATE_NAMESPACE,
  SystemPermission::DROP_NAMESPACE,
  SystemPermission::ALTER_NAMESPACE,
  SystemPermission::OBTAIN_DELEGATION_TOKEN
};
const char* _kSystemPermissionNames[] = {
  "GRANT",
  "CREATE_TABLE",
  "DROP_TABLE",
  "ALTER_TABLE",
  "CREATE_USER",
  "DROP_USER",
  "ALTER_USER",
  "SYSTEM",
  "CREATE_NAMESPACE",
  "DROP_NAMESPACE",
  "ALTER_NAMESPACE",
  "OBTAIN_DELEGATION_TOKEN"
};
const std::map<int, const char*> _SystemPermission_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kSystemPermissionValues, _kSystemPermissionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kNamespacePermissionValues[] = {
  NamespacePermission::READ,
  NamespacePermission::WRITE,
  NamespacePermission::ALTER_NAMESPACE,
  NamespacePermission::GRANT,
  NamespacePermission::ALTER_TABLE,
  NamespacePermission::CREATE_TABLE,
  NamespacePermission::DROP_TABLE,
  NamespacePermission::BULK_IMPORT,
  NamespacePermission::DROP_NAMESPACE
};
const char* _kNamespacePermissionNames[] = {
  "READ",
  "WRITE",
  "ALTER_NAMESPACE",
  "GRANT",
  "ALTER_TABLE",
  "CREATE_TABLE",
  "DROP_TABLE",
  "BULK_IMPORT",
  "DROP_NAMESPACE"
};
const std::map<int, const char*> _NamespacePermission_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kNamespacePermissionValues, _kNamespacePermissionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kScanTypeValues[] = {
  ScanType::SINGLE,
  ScanType::BATCH
};
const char* _kScanTypeNames[] = {
  "SINGLE",
  "BATCH"
};
const std::map<int, const char*> _ScanType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kScanTypeValues, _kScanTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kScanStateValues[] = {
  ScanState::IDLE,
  ScanState::RUNNING,
  ScanState::QUEUED
};
const char* _kScanStateNames[] = {
  "IDLE",
  "RUNNING",
  "QUEUED"
};
const std::map<int, const char*> _ScanState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kScanStateValues, _kScanStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kConditionalStatusValues[] = {
  ConditionalStatus::ACCEPTED,
  ConditionalStatus::REJECTED,
  ConditionalStatus::VIOLATED,
  ConditionalStatus::UNKNOWN,
  ConditionalStatus::INVISIBLE_VISIBILITY
};
const char* _kConditionalStatusNames[] = {
  "ACCEPTED",
  "REJECTED",
  "VIOLATED",
  "UNKNOWN",
  "INVISIBLE_VISIBILITY"
};
const std::map<int, const char*> _ConditionalStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kConditionalStatusValues, _kConditionalStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDurabilityValues[] = {
  Durability::DEFAULT,
  Durability::NONE,
  Durability::LOG,
  Durability::FLUSH,
  Durability::SYNC
};
const char* _kDurabilityNames[] = {
  "DEFAULT",
  "NONE",
  "LOG",
  "FLUSH",
  "SYNC"
};
const std::map<int, const char*> _Durability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kDurabilityValues, _kDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MERGE,
  CompactionType::MAJOR,
  CompactionType::FULL
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MERGE",
  "MAJOR",
  "FULL"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompactionReasonValues[] = {
  CompactionReason::USER,
  CompactionReason::SYSTEM,
  CompactionReason::CHOP,
  CompactionReason::IDLE,
  CompactionReason::CLOSE
};
const char* _kCompactionReasonNames[] = {
  "USER",
  "SYSTEM",
  "CHOP",
  "IDLE",
  "CLOSE"
};
const std::map<int, const char*> _CompactionReason_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCompactionReasonValues, _kCompactionReasonNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIteratorScopeValues[] = {
  IteratorScope::MINC,
  IteratorScope::MAJC,
  IteratorScope::SCAN
};
const char* _kIteratorScopeNames[] = {
  "MINC",
  "MAJC",
  "SCAN"
};
const std::map<int, const char*> _IteratorScope_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIteratorScopeValues, _kIteratorScopeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTimeTypeValues[] = {
  TimeType::LOGICAL,
  TimeType::MILLIS
};
const char* _kTimeTypeNames[] = {
  "LOGICAL",
  "MILLIS"
};
const std::map<int, const char*> _TimeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTimeTypeValues, _kTimeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Key::~Key() throw() {
}


void Key::__set_row(const std::string& val) {
  this->row = val;
}

void Key::__set_colFamily(const std::string& val) {
  this->colFamily = val;
}

void Key::__set_colQualifier(const std::string& val) {
  this->colQualifier = val;
}

void Key::__set_colVisibility(const std::string& val) {
  this->colVisibility = val;
}

void Key::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

uint32_t Key::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Key::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Key");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->colVisibility);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Key &a, Key &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

Key::Key(const Key& other0) {
  row = other0.row;
  colFamily = other0.colFamily;
  colQualifier = other0.colQualifier;
  colVisibility = other0.colVisibility;
  timestamp = other0.timestamp;
  __isset = other0.__isset;
}
Key& Key::operator=(const Key& other1) {
  row = other1.row;
  colFamily = other1.colFamily;
  colQualifier = other1.colQualifier;
  colVisibility = other1.colVisibility;
  timestamp = other1.timestamp;
  __isset = other1.__isset;
  return *this;
}
void Key::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Key(";
  out << "row=" << to_string(row);
  out << ", " << "colFamily=" << to_string(colFamily);
  out << ", " << "colQualifier=" << to_string(colQualifier);
  out << ", " << "colVisibility=" << to_string(colVisibility);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ")";
}


ColumnUpdate::~ColumnUpdate() throw() {
}


void ColumnUpdate::__set_colFamily(const std::string& val) {
  this->colFamily = val;
}

void ColumnUpdate::__set_colQualifier(const std::string& val) {
  this->colQualifier = val;
}

void ColumnUpdate::__set_colVisibility(const std::string& val) {
  this->colVisibility = val;
__isset.colVisibility = true;
}

void ColumnUpdate::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void ColumnUpdate::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

void ColumnUpdate::__set_deleteCell(const bool val) {
  this->deleteCell = val;
__isset.deleteCell = true;
}

uint32_t ColumnUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteCell);
          this->__isset.deleteCell = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnUpdate");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.colVisibility) {
    xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->colVisibility);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteCell) {
    xfer += oprot->writeFieldBegin("deleteCell", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->deleteCell);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnUpdate &a, ColumnUpdate &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.timestamp, b.timestamp);
  swap(a.value, b.value);
  swap(a.deleteCell, b.deleteCell);
  swap(a.__isset, b.__isset);
}

ColumnUpdate::ColumnUpdate(const ColumnUpdate& other2) {
  colFamily = other2.colFamily;
  colQualifier = other2.colQualifier;
  colVisibility = other2.colVisibility;
  timestamp = other2.timestamp;
  value = other2.value;
  deleteCell = other2.deleteCell;
  __isset = other2.__isset;
}
ColumnUpdate& ColumnUpdate::operator=(const ColumnUpdate& other3) {
  colFamily = other3.colFamily;
  colQualifier = other3.colQualifier;
  colVisibility = other3.colVisibility;
  timestamp = other3.timestamp;
  value = other3.value;
  deleteCell = other3.deleteCell;
  __isset = other3.__isset;
  return *this;
}
void ColumnUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnUpdate(";
  out << "colFamily=" << to_string(colFamily);
  out << ", " << "colQualifier=" << to_string(colQualifier);
  out << ", " << "colVisibility="; (__isset.colVisibility ? (out << to_string(colVisibility)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "deleteCell="; (__isset.deleteCell ? (out << to_string(deleteCell)) : (out << "<null>"));
  out << ")";
}


DiskUsage::~DiskUsage() throw() {
}


void DiskUsage::__set_tables(const std::vector<std::string> & val) {
  this->tables = val;
}

void DiskUsage::__set_usage(const int64_t val) {
  this->usage = val;
}

uint32_t DiskUsage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->tables.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readString(this->tables[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->usage);
          this->__isset.usage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiskUsage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiskUsage");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
    std::vector<std::string> ::const_iterator _iter9;
    for (_iter9 = this->tables.begin(); _iter9 != this->tables.end(); ++_iter9)
    {
      xfer += oprot->writeString((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usage", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->usage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiskUsage &a, DiskUsage &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
  swap(a.usage, b.usage);
  swap(a.__isset, b.__isset);
}

DiskUsage::DiskUsage(const DiskUsage& other10) {
  tables = other10.tables;
  usage = other10.usage;
  __isset = other10.__isset;
}
DiskUsage& DiskUsage::operator=(const DiskUsage& other11) {
  tables = other11.tables;
  usage = other11.usage;
  __isset = other11.__isset;
  return *this;
}
void DiskUsage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiskUsage(";
  out << "tables=" << to_string(tables);
  out << ", " << "usage=" << to_string(usage);
  out << ")";
}


KeyValue::~KeyValue() throw() {
}


void KeyValue::__set_key(const Key& val) {
  this->key = val;
}

void KeyValue::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t KeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyValue");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyValue &a, KeyValue &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

KeyValue::KeyValue(const KeyValue& other12) {
  key = other12.key;
  value = other12.value;
  __isset = other12.__isset;
}
KeyValue& KeyValue::operator=(const KeyValue& other13) {
  key = other13.key;
  value = other13.value;
  __isset = other13.__isset;
  return *this;
}
void KeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyValue(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


ScanResult::~ScanResult() throw() {
}


void ScanResult::__set_results(const std::vector<KeyValue> & val) {
  this->results = val;
}

void ScanResult::__set_more(const bool val) {
  this->more = val;
}

uint32_t ScanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->results.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->results[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->more);
          this->__isset.more = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector<KeyValue> ::const_iterator _iter19;
    for (_iter19 = this->results.begin(); _iter19 != this->results.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->more);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanResult &a, ScanResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
  swap(a.more, b.more);
  swap(a.__isset, b.__isset);
}

ScanResult::ScanResult(const ScanResult& other20) {
  results = other20.results;
  more = other20.more;
  __isset = other20.__isset;
}
ScanResult& ScanResult::operator=(const ScanResult& other21) {
  results = other21.results;
  more = other21.more;
  __isset = other21.__isset;
  return *this;
}
void ScanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanResult(";
  out << "results=" << to_string(results);
  out << ", " << "more=" << to_string(more);
  out << ")";
}


Range::~Range() throw() {
}


void Range::__set_start(const Key& val) {
  this->start = val;
}

void Range::__set_startInclusive(const bool val) {
  this->startInclusive = val;
}

void Range::__set_stop(const Key& val) {
  this->stop = val;
}

void Range::__set_stopInclusive(const bool val) {
  this->stopInclusive = val;
}

uint32_t Range::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startInclusive);
          this->__isset.startInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stop.read(iprot);
          this->__isset.stop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->stopInclusive);
          this->__isset.stopInclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Range");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startInclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stop", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stopInclusive", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->stopInclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Range &a, Range &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.startInclusive, b.startInclusive);
  swap(a.stop, b.stop);
  swap(a.stopInclusive, b.stopInclusive);
  swap(a.__isset, b.__isset);
}

Range::Range(const Range& other22) {
  start = other22.start;
  startInclusive = other22.startInclusive;
  stop = other22.stop;
  stopInclusive = other22.stopInclusive;
  __isset = other22.__isset;
}
Range& Range::operator=(const Range& other23) {
  start = other23.start;
  startInclusive = other23.startInclusive;
  stop = other23.stop;
  stopInclusive = other23.stopInclusive;
  __isset = other23.__isset;
  return *this;
}
void Range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Range(";
  out << "start=" << to_string(start);
  out << ", " << "startInclusive=" << to_string(startInclusive);
  out << ", " << "stop=" << to_string(stop);
  out << ", " << "stopInclusive=" << to_string(stopInclusive);
  out << ")";
}


ScanColumn::~ScanColumn() throw() {
}


void ScanColumn::__set_colFamily(const std::string& val) {
  this->colFamily = val;
}

void ScanColumn::__set_colQualifier(const std::string& val) {
  this->colQualifier = val;
__isset.colQualifier = true;
}

uint32_t ScanColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanColumn");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.colQualifier) {
    xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->colQualifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanColumn &a, ScanColumn &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.__isset, b.__isset);
}

ScanColumn::ScanColumn(const ScanColumn& other24) {
  colFamily = other24.colFamily;
  colQualifier = other24.colQualifier;
  __isset = other24.__isset;
}
ScanColumn& ScanColumn::operator=(const ScanColumn& other25) {
  colFamily = other25.colFamily;
  colQualifier = other25.colQualifier;
  __isset = other25.__isset;
  return *this;
}
void ScanColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanColumn(";
  out << "colFamily=" << to_string(colFamily);
  out << ", " << "colQualifier="; (__isset.colQualifier ? (out << to_string(colQualifier)) : (out << "<null>"));
  out << ")";
}


IteratorSetting::~IteratorSetting() throw() {
}


void IteratorSetting::__set_priority(const int32_t val) {
  this->priority = val;
}

void IteratorSetting::__set_name(const std::string& val) {
  this->name = val;
}

void IteratorSetting::__set_iteratorClass(const std::string& val) {
  this->iteratorClass = val;
}

void IteratorSetting::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

uint32_t IteratorSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iteratorClass);
          this->__isset.iteratorClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              std::string _key31;
              xfer += iprot->readString(_key31);
              std::string& _val32 = this->properties[_key31];
              xfer += iprot->readString(_val32);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IteratorSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IteratorSetting");

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iteratorClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->iteratorClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter33;
    for (_iter33 = this->properties.begin(); _iter33 != this->properties.end(); ++_iter33)
    {
      xfer += oprot->writeString(_iter33->first);
      xfer += oprot->writeString(_iter33->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IteratorSetting &a, IteratorSetting &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.name, b.name);
  swap(a.iteratorClass, b.iteratorClass);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

IteratorSetting::IteratorSetting(const IteratorSetting& other34) {
  priority = other34.priority;
  name = other34.name;
  iteratorClass = other34.iteratorClass;
  properties = other34.properties;
  __isset = other34.__isset;
}
IteratorSetting& IteratorSetting::operator=(const IteratorSetting& other35) {
  priority = other35.priority;
  name = other35.name;
  iteratorClass = other35.iteratorClass;
  properties = other35.properties;
  __isset = other35.__isset;
  return *this;
}
void IteratorSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IteratorSetting(";
  out << "priority=" << to_string(priority);
  out << ", " << "name=" << to_string(name);
  out << ", " << "iteratorClass=" << to_string(iteratorClass);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


ScanOptions::~ScanOptions() throw() {
}


void ScanOptions::__set_authorizations(const std::set<std::string> & val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void ScanOptions::__set_range(const Range& val) {
  this->range = val;
__isset.range = true;
}

void ScanOptions::__set_columns(const std::vector<ScanColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void ScanOptions::__set_iterators(const std::vector<IteratorSetting> & val) {
  this->iterators = val;
__isset.iterators = true;
}

void ScanOptions::__set_bufferSize(const int32_t val) {
  this->bufferSize = val;
__isset.bufferSize = true;
}

uint32_t ScanOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readSetBegin(_etype39, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              std::string _elem41;
              xfer += iprot->readBinary(_elem41);
              this->authorizations.insert(_elem41);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range.read(iprot);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->columns.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->columns[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->iterators.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->iterators[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bufferSize);
          this->__isset.bufferSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScanOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanOptions");

  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
      std::set<std::string> ::const_iterator _iter52;
      for (_iter52 = this->authorizations.begin(); _iter52 != this->authorizations.end(); ++_iter52)
      {
        xfer += oprot->writeBinary((*_iter52));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range) {
    xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<ScanColumn> ::const_iterator _iter53;
      for (_iter53 = this->columns.begin(); _iter53 != this->columns.end(); ++_iter53)
      {
        xfer += (*_iter53).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iterators) {
    xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
      std::vector<IteratorSetting> ::const_iterator _iter54;
      for (_iter54 = this->iterators.begin(); _iter54 != this->iterators.end(); ++_iter54)
      {
        xfer += (*_iter54).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bufferSize) {
    xfer += oprot->writeFieldBegin("bufferSize", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->bufferSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanOptions &a, ScanOptions &b) {
  using ::std::swap;
  swap(a.authorizations, b.authorizations);
  swap(a.range, b.range);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.bufferSize, b.bufferSize);
  swap(a.__isset, b.__isset);
}

ScanOptions::ScanOptions(const ScanOptions& other55) {
  authorizations = other55.authorizations;
  range = other55.range;
  columns = other55.columns;
  iterators = other55.iterators;
  bufferSize = other55.bufferSize;
  __isset = other55.__isset;
}
ScanOptions& ScanOptions::operator=(const ScanOptions& other56) {
  authorizations = other56.authorizations;
  range = other56.range;
  columns = other56.columns;
  iterators = other56.iterators;
  bufferSize = other56.bufferSize;
  __isset = other56.__isset;
  return *this;
}
void ScanOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanOptions(";
  out << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "range="; (__isset.range ? (out << to_string(range)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "iterators="; (__isset.iterators ? (out << to_string(iterators)) : (out << "<null>"));
  out << ", " << "bufferSize="; (__isset.bufferSize ? (out << to_string(bufferSize)) : (out << "<null>"));
  out << ")";
}


BatchScanOptions::~BatchScanOptions() throw() {
}


void BatchScanOptions::__set_authorizations(const std::set<std::string> & val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void BatchScanOptions::__set_ranges(const std::vector<Range> & val) {
  this->ranges = val;
__isset.ranges = true;
}

void BatchScanOptions::__set_columns(const std::vector<ScanColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void BatchScanOptions::__set_iterators(const std::vector<IteratorSetting> & val) {
  this->iterators = val;
__isset.iterators = true;
}

void BatchScanOptions::__set_threads(const int32_t val) {
  this->threads = val;
__isset.threads = true;
}

uint32_t BatchScanOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readSetBegin(_etype60, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              std::string _elem62;
              xfer += iprot->readBinary(_elem62);
              this->authorizations.insert(_elem62);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->ranges.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->ranges[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->columns.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += this->columns[_i72].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->iterators.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->iterators[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BatchScanOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BatchScanOptions");

  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
      std::set<std::string> ::const_iterator _iter78;
      for (_iter78 = this->authorizations.begin(); _iter78 != this->authorizations.end(); ++_iter78)
      {
        xfer += oprot->writeBinary((*_iter78));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ranges) {
    xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
      std::vector<Range> ::const_iterator _iter79;
      for (_iter79 = this->ranges.begin(); _iter79 != this->ranges.end(); ++_iter79)
      {
        xfer += (*_iter79).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<ScanColumn> ::const_iterator _iter80;
      for (_iter80 = this->columns.begin(); _iter80 != this->columns.end(); ++_iter80)
      {
        xfer += (*_iter80).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iterators) {
    xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
      std::vector<IteratorSetting> ::const_iterator _iter81;
      for (_iter81 = this->iterators.begin(); _iter81 != this->iterators.end(); ++_iter81)
      {
        xfer += (*_iter81).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.threads) {
    xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->threads);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BatchScanOptions &a, BatchScanOptions &b) {
  using ::std::swap;
  swap(a.authorizations, b.authorizations);
  swap(a.ranges, b.ranges);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.threads, b.threads);
  swap(a.__isset, b.__isset);
}

BatchScanOptions::BatchScanOptions(const BatchScanOptions& other82) {
  authorizations = other82.authorizations;
  ranges = other82.ranges;
  columns = other82.columns;
  iterators = other82.iterators;
  threads = other82.threads;
  __isset = other82.__isset;
}
BatchScanOptions& BatchScanOptions::operator=(const BatchScanOptions& other83) {
  authorizations = other83.authorizations;
  ranges = other83.ranges;
  columns = other83.columns;
  iterators = other83.iterators;
  threads = other83.threads;
  __isset = other83.__isset;
  return *this;
}
void BatchScanOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BatchScanOptions(";
  out << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "ranges="; (__isset.ranges ? (out << to_string(ranges)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "iterators="; (__isset.iterators ? (out << to_string(iterators)) : (out << "<null>"));
  out << ", " << "threads="; (__isset.threads ? (out << to_string(threads)) : (out << "<null>"));
  out << ")";
}


KeyValueAndPeek::~KeyValueAndPeek() throw() {
}


void KeyValueAndPeek::__set_keyValue(const KeyValue& val) {
  this->keyValue = val;
}

void KeyValueAndPeek::__set_hasNext(const bool val) {
  this->hasNext = val;
}

uint32_t KeyValueAndPeek::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->keyValue.read(iprot);
          this->__isset.keyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasNext);
          this->__isset.hasNext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyValueAndPeek::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyValueAndPeek");

  xfer += oprot->writeFieldBegin("keyValue", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->keyValue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasNext", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasNext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyValueAndPeek &a, KeyValueAndPeek &b) {
  using ::std::swap;
  swap(a.keyValue, b.keyValue);
  swap(a.hasNext, b.hasNext);
  swap(a.__isset, b.__isset);
}

KeyValueAndPeek::KeyValueAndPeek(const KeyValueAndPeek& other84) {
  keyValue = other84.keyValue;
  hasNext = other84.hasNext;
  __isset = other84.__isset;
}
KeyValueAndPeek& KeyValueAndPeek::operator=(const KeyValueAndPeek& other85) {
  keyValue = other85.keyValue;
  hasNext = other85.hasNext;
  __isset = other85.__isset;
  return *this;
}
void KeyValueAndPeek::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyValueAndPeek(";
  out << "keyValue=" << to_string(keyValue);
  out << ", " << "hasNext=" << to_string(hasNext);
  out << ")";
}


KeyExtent::~KeyExtent() throw() {
}


void KeyExtent::__set_tableId(const std::string& val) {
  this->tableId = val;
}

void KeyExtent::__set_endRow(const std::string& val) {
  this->endRow = val;
}

void KeyExtent::__set_prevEndRow(const std::string& val) {
  this->prevEndRow = val;
}

uint32_t KeyExtent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endRow);
          this->__isset.endRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->prevEndRow);
          this->__isset.prevEndRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyExtent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyExtent");

  xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endRow", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->endRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevEndRow", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->prevEndRow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyExtent &a, KeyExtent &b) {
  using ::std::swap;
  swap(a.tableId, b.tableId);
  swap(a.endRow, b.endRow);
  swap(a.prevEndRow, b.prevEndRow);
  swap(a.__isset, b.__isset);
}

KeyExtent::KeyExtent(const KeyExtent& other86) {
  tableId = other86.tableId;
  endRow = other86.endRow;
  prevEndRow = other86.prevEndRow;
  __isset = other86.__isset;
}
KeyExtent& KeyExtent::operator=(const KeyExtent& other87) {
  tableId = other87.tableId;
  endRow = other87.endRow;
  prevEndRow = other87.prevEndRow;
  __isset = other87.__isset;
  return *this;
}
void KeyExtent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyExtent(";
  out << "tableId=" << to_string(tableId);
  out << ", " << "endRow=" << to_string(endRow);
  out << ", " << "prevEndRow=" << to_string(prevEndRow);
  out << ")";
}


Column::~Column() throw() {
}


void Column::__set_colFamily(const std::string& val) {
  this->colFamily = val;
}

void Column::__set_colQualifier(const std::string& val) {
  this->colQualifier = val;
}

void Column::__set_colVisibility(const std::string& val) {
  this->colVisibility = val;
}

uint32_t Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colFamily);
          this->__isset.colFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colQualifier);
          this->__isset.colQualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->colVisibility);
          this->__isset.colVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Column");

  xfer += oprot->writeFieldBegin("colFamily", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->colFamily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colQualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->colQualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colVisibility", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->colVisibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Column &a, Column &b) {
  using ::std::swap;
  swap(a.colFamily, b.colFamily);
  swap(a.colQualifier, b.colQualifier);
  swap(a.colVisibility, b.colVisibility);
  swap(a.__isset, b.__isset);
}

Column::Column(const Column& other88) {
  colFamily = other88.colFamily;
  colQualifier = other88.colQualifier;
  colVisibility = other88.colVisibility;
  __isset = other88.__isset;
}
Column& Column::operator=(const Column& other89) {
  colFamily = other89.colFamily;
  colQualifier = other89.colQualifier;
  colVisibility = other89.colVisibility;
  __isset = other89.__isset;
  return *this;
}
void Column::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Column(";
  out << "colFamily=" << to_string(colFamily);
  out << ", " << "colQualifier=" << to_string(colQualifier);
  out << ", " << "colVisibility=" << to_string(colVisibility);
  out << ")";
}


Condition::~Condition() throw() {
}


void Condition::__set_column(const Column& val) {
  this->column = val;
}

void Condition::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void Condition::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

void Condition::__set_iterators(const std::vector<IteratorSetting> & val) {
  this->iterators = val;
__isset.iterators = true;
}

uint32_t Condition::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column.read(iprot);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->iterators.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += this->iterators[_i94].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Condition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Condition");

  xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->column.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iterators) {
    xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
      std::vector<IteratorSetting> ::const_iterator _iter95;
      for (_iter95 = this->iterators.begin(); _iter95 != this->iterators.end(); ++_iter95)
      {
        xfer += (*_iter95).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Condition &a, Condition &b) {
  using ::std::swap;
  swap(a.column, b.column);
  swap(a.timestamp, b.timestamp);
  swap(a.value, b.value);
  swap(a.iterators, b.iterators);
  swap(a.__isset, b.__isset);
}

Condition::Condition(const Condition& other96) {
  column = other96.column;
  timestamp = other96.timestamp;
  value = other96.value;
  iterators = other96.iterators;
  __isset = other96.__isset;
}
Condition& Condition::operator=(const Condition& other97) {
  column = other97.column;
  timestamp = other97.timestamp;
  value = other97.value;
  iterators = other97.iterators;
  __isset = other97.__isset;
  return *this;
}
void Condition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Condition(";
  out << "column=" << to_string(column);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "iterators="; (__isset.iterators ? (out << to_string(iterators)) : (out << "<null>"));
  out << ")";
}


ConditionalUpdates::~ConditionalUpdates() throw() {
}


void ConditionalUpdates::__set_conditions(const std::vector<Condition> & val) {
  this->conditions = val;
}

void ConditionalUpdates::__set_updates(const std::vector<ColumnUpdate> & val) {
  this->updates = val;
}

uint32_t ConditionalUpdates::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conditions.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->conditions.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += this->conditions[_i102].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->updates.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += this->updates[_i107].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConditionalUpdates::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConditionalUpdates");

  xfer += oprot->writeFieldBegin("conditions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conditions.size()));
    std::vector<Condition> ::const_iterator _iter108;
    for (_iter108 = this->conditions.begin(); _iter108 != this->conditions.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<ColumnUpdate> ::const_iterator _iter109;
    for (_iter109 = this->updates.begin(); _iter109 != this->updates.end(); ++_iter109)
    {
      xfer += (*_iter109).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConditionalUpdates &a, ConditionalUpdates &b) {
  using ::std::swap;
  swap(a.conditions, b.conditions);
  swap(a.updates, b.updates);
  swap(a.__isset, b.__isset);
}

ConditionalUpdates::ConditionalUpdates(const ConditionalUpdates& other110) {
  conditions = other110.conditions;
  updates = other110.updates;
  __isset = other110.__isset;
}
ConditionalUpdates& ConditionalUpdates::operator=(const ConditionalUpdates& other111) {
  conditions = other111.conditions;
  updates = other111.updates;
  __isset = other111.__isset;
  return *this;
}
void ConditionalUpdates::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConditionalUpdates(";
  out << "conditions=" << to_string(conditions);
  out << ", " << "updates=" << to_string(updates);
  out << ")";
}


ConditionalWriterOptions::~ConditionalWriterOptions() throw() {
}


void ConditionalWriterOptions::__set_maxMemory(const int64_t val) {
  this->maxMemory = val;
__isset.maxMemory = true;
}

void ConditionalWriterOptions::__set_timeoutMs(const int64_t val) {
  this->timeoutMs = val;
__isset.timeoutMs = true;
}

void ConditionalWriterOptions::__set_threads(const int32_t val) {
  this->threads = val;
__isset.threads = true;
}

void ConditionalWriterOptions::__set_authorizations(const std::set<std::string> & val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void ConditionalWriterOptions::__set_durability(const Durability::type val) {
  this->durability = val;
__isset.durability = true;
}

uint32_t ConditionalWriterOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxMemory);
          this->__isset.maxMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeoutMs);
          this->__isset.timeoutMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->authorizations.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readSetBegin(_etype115, _size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              std::string _elem117;
              xfer += iprot->readBinary(_elem117);
              this->authorizations.insert(_elem117);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast118;
          xfer += iprot->readI32(ecast118);
          this->durability = (Durability::type)ecast118;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConditionalWriterOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConditionalWriterOptions");

  if (this->__isset.maxMemory) {
    xfer += oprot->writeFieldBegin("maxMemory", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->maxMemory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeoutMs) {
    xfer += oprot->writeFieldBegin("timeoutMs", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timeoutMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.threads) {
    xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
      std::set<std::string> ::const_iterator _iter119;
      for (_iter119 = this->authorizations.begin(); _iter119 != this->authorizations.end(); ++_iter119)
      {
        xfer += oprot->writeBinary((*_iter119));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConditionalWriterOptions &a, ConditionalWriterOptions &b) {
  using ::std::swap;
  swap(a.maxMemory, b.maxMemory);
  swap(a.timeoutMs, b.timeoutMs);
  swap(a.threads, b.threads);
  swap(a.authorizations, b.authorizations);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

ConditionalWriterOptions::ConditionalWriterOptions(const ConditionalWriterOptions& other120) {
  maxMemory = other120.maxMemory;
  timeoutMs = other120.timeoutMs;
  threads = other120.threads;
  authorizations = other120.authorizations;
  durability = other120.durability;
  __isset = other120.__isset;
}
ConditionalWriterOptions& ConditionalWriterOptions::operator=(const ConditionalWriterOptions& other121) {
  maxMemory = other121.maxMemory;
  timeoutMs = other121.timeoutMs;
  threads = other121.threads;
  authorizations = other121.authorizations;
  durability = other121.durability;
  __isset = other121.__isset;
  return *this;
}
void ConditionalWriterOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConditionalWriterOptions(";
  out << "maxMemory="; (__isset.maxMemory ? (out << to_string(maxMemory)) : (out << "<null>"));
  out << ", " << "timeoutMs="; (__isset.timeoutMs ? (out << to_string(timeoutMs)) : (out << "<null>"));
  out << ", " << "threads="; (__isset.threads ? (out << to_string(threads)) : (out << "<null>"));
  out << ", " << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ")";
}


ActiveScan::~ActiveScan() throw() {
}


void ActiveScan::__set_client(const std::string& val) {
  this->client = val;
}

void ActiveScan::__set_user(const std::string& val) {
  this->user = val;
}

void ActiveScan::__set_table(const std::string& val) {
  this->table = val;
}

void ActiveScan::__set_age(const int64_t val) {
  this->age = val;
}

void ActiveScan::__set_idleTime(const int64_t val) {
  this->idleTime = val;
}

void ActiveScan::__set_type(const ScanType::type val) {
  this->type = val;
}

void ActiveScan::__set_state(const ScanState::type val) {
  this->state = val;
}

void ActiveScan::__set_extent(const KeyExtent& val) {
  this->extent = val;
}

void ActiveScan::__set_columns(const std::vector<Column> & val) {
  this->columns = val;
}

void ActiveScan::__set_iterators(const std::vector<IteratorSetting> & val) {
  this->iterators = val;
}

void ActiveScan::__set_authorizations(const std::vector<std::string> & val) {
  this->authorizations = val;
}

uint32_t ActiveScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client);
          this->__isset.client = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->idleTime);
          this->__isset.idleTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast122;
          xfer += iprot->readI32(ecast122);
          this->type = (ScanType::type)ecast122;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->state = (ScanState::type)ecast123;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->columns.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += this->columns[_i128].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->iterators.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += this->iterators[_i133].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->authorizations.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->authorizations.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += iprot->readBinary(this->authorizations[_i138]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActiveScan");

  xfer += oprot->writeFieldBegin("client", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->client);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idleTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->idleTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter139;
    for (_iter139 = this->columns.begin(); _iter139 != this->columns.end(); ++_iter139)
    {
      xfer += (*_iter139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<IteratorSetting> ::const_iterator _iter140;
    for (_iter140 = this->iterators.begin(); _iter140 != this->iterators.end(); ++_iter140)
    {
      xfer += (*_iter140).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->authorizations.size()));
    std::vector<std::string> ::const_iterator _iter141;
    for (_iter141 = this->authorizations.begin(); _iter141 != this->authorizations.end(); ++_iter141)
    {
      xfer += oprot->writeBinary((*_iter141));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveScan &a, ActiveScan &b) {
  using ::std::swap;
  swap(a.client, b.client);
  swap(a.user, b.user);
  swap(a.table, b.table);
  swap(a.age, b.age);
  swap(a.idleTime, b.idleTime);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.extent, b.extent);
  swap(a.columns, b.columns);
  swap(a.iterators, b.iterators);
  swap(a.authorizations, b.authorizations);
  swap(a.__isset, b.__isset);
}

ActiveScan::ActiveScan(const ActiveScan& other142) {
  client = other142.client;
  user = other142.user;
  table = other142.table;
  age = other142.age;
  idleTime = other142.idleTime;
  type = other142.type;
  state = other142.state;
  extent = other142.extent;
  columns = other142.columns;
  iterators = other142.iterators;
  authorizations = other142.authorizations;
  __isset = other142.__isset;
}
ActiveScan& ActiveScan::operator=(const ActiveScan& other143) {
  client = other143.client;
  user = other143.user;
  table = other143.table;
  age = other143.age;
  idleTime = other143.idleTime;
  type = other143.type;
  state = other143.state;
  extent = other143.extent;
  columns = other143.columns;
  iterators = other143.iterators;
  authorizations = other143.authorizations;
  __isset = other143.__isset;
  return *this;
}
void ActiveScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActiveScan(";
  out << "client=" << to_string(client);
  out << ", " << "user=" << to_string(user);
  out << ", " << "table=" << to_string(table);
  out << ", " << "age=" << to_string(age);
  out << ", " << "idleTime=" << to_string(idleTime);
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "extent=" << to_string(extent);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "iterators=" << to_string(iterators);
  out << ", " << "authorizations=" << to_string(authorizations);
  out << ")";
}


ActiveCompaction::~ActiveCompaction() throw() {
}


void ActiveCompaction::__set_extent(const KeyExtent& val) {
  this->extent = val;
}

void ActiveCompaction::__set_age(const int64_t val) {
  this->age = val;
}

void ActiveCompaction::__set_inputFiles(const std::vector<std::string> & val) {
  this->inputFiles = val;
}

void ActiveCompaction::__set_outputFile(const std::string& val) {
  this->outputFile = val;
}

void ActiveCompaction::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ActiveCompaction::__set_reason(const CompactionReason::type val) {
  this->reason = val;
}

void ActiveCompaction::__set_localityGroup(const std::string& val) {
  this->localityGroup = val;
}

void ActiveCompaction::__set_entriesRead(const int64_t val) {
  this->entriesRead = val;
}

void ActiveCompaction::__set_entriesWritten(const int64_t val) {
  this->entriesWritten = val;
}

void ActiveCompaction::__set_iterators(const std::vector<IteratorSetting> & val) {
  this->iterators = val;
}

uint32_t ActiveCompaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extent.read(iprot);
          this->__isset.extent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputFiles.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->inputFiles.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readString(this->inputFiles[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFile);
          this->__isset.outputFile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast149;
          xfer += iprot->readI32(ecast149);
          this->type = (CompactionType::type)ecast149;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->reason = (CompactionReason::type)ecast150;
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localityGroup);
          this->__isset.localityGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesRead);
          this->__isset.entriesRead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entriesWritten);
          this->__isset.entriesWritten = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterators.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->iterators.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += this->iterators[_i155].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iterators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActiveCompaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActiveCompaction");

  xfer += oprot->writeFieldBegin("extent", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->age);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFiles", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->inputFiles.size()));
    std::vector<std::string> ::const_iterator _iter156;
    for (_iter156 = this->inputFiles.begin(); _iter156 != this->inputFiles.end(); ++_iter156)
    {
      xfer += oprot->writeString((*_iter156));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFile", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->reason);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("localityGroup", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->localityGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesRead", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->entriesRead);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entriesWritten", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->entriesWritten);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iterators", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterators.size()));
    std::vector<IteratorSetting> ::const_iterator _iter157;
    for (_iter157 = this->iterators.begin(); _iter157 != this->iterators.end(); ++_iter157)
    {
      xfer += (*_iter157).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActiveCompaction &a, ActiveCompaction &b) {
  using ::std::swap;
  swap(a.extent, b.extent);
  swap(a.age, b.age);
  swap(a.inputFiles, b.inputFiles);
  swap(a.outputFile, b.outputFile);
  swap(a.type, b.type);
  swap(a.reason, b.reason);
  swap(a.localityGroup, b.localityGroup);
  swap(a.entriesRead, b.entriesRead);
  swap(a.entriesWritten, b.entriesWritten);
  swap(a.iterators, b.iterators);
  swap(a.__isset, b.__isset);
}

ActiveCompaction::ActiveCompaction(const ActiveCompaction& other158) {
  extent = other158.extent;
  age = other158.age;
  inputFiles = other158.inputFiles;
  outputFile = other158.outputFile;
  type = other158.type;
  reason = other158.reason;
  localityGroup = other158.localityGroup;
  entriesRead = other158.entriesRead;
  entriesWritten = other158.entriesWritten;
  iterators = other158.iterators;
  __isset = other158.__isset;
}
ActiveCompaction& ActiveCompaction::operator=(const ActiveCompaction& other159) {
  extent = other159.extent;
  age = other159.age;
  inputFiles = other159.inputFiles;
  outputFile = other159.outputFile;
  type = other159.type;
  reason = other159.reason;
  localityGroup = other159.localityGroup;
  entriesRead = other159.entriesRead;
  entriesWritten = other159.entriesWritten;
  iterators = other159.iterators;
  __isset = other159.__isset;
  return *this;
}
void ActiveCompaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActiveCompaction(";
  out << "extent=" << to_string(extent);
  out << ", " << "age=" << to_string(age);
  out << ", " << "inputFiles=" << to_string(inputFiles);
  out << ", " << "outputFile=" << to_string(outputFile);
  out << ", " << "type=" << to_string(type);
  out << ", " << "reason=" << to_string(reason);
  out << ", " << "localityGroup=" << to_string(localityGroup);
  out << ", " << "entriesRead=" << to_string(entriesRead);
  out << ", " << "entriesWritten=" << to_string(entriesWritten);
  out << ", " << "iterators=" << to_string(iterators);
  out << ")";
}


WriterOptions::~WriterOptions() throw() {
}


void WriterOptions::__set_maxMemory(const int64_t val) {
  this->maxMemory = val;
}

void WriterOptions::__set_latencyMs(const int64_t val) {
  this->latencyMs = val;
}

void WriterOptions::__set_timeoutMs(const int64_t val) {
  this->timeoutMs = val;
}

void WriterOptions::__set_threads(const int32_t val) {
  this->threads = val;
}

void WriterOptions::__set_durability(const Durability::type val) {
  this->durability = val;
__isset.durability = true;
}

uint32_t WriterOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxMemory);
          this->__isset.maxMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latencyMs);
          this->__isset.latencyMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeoutMs);
          this->__isset.timeoutMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast160;
          xfer += iprot->readI32(ecast160);
          this->durability = (Durability::type)ecast160;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WriterOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriterOptions");

  xfer += oprot->writeFieldBegin("maxMemory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxMemory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latencyMs", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->latencyMs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeoutMs", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->timeoutMs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriterOptions &a, WriterOptions &b) {
  using ::std::swap;
  swap(a.maxMemory, b.maxMemory);
  swap(a.latencyMs, b.latencyMs);
  swap(a.timeoutMs, b.timeoutMs);
  swap(a.threads, b.threads);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

WriterOptions::WriterOptions(const WriterOptions& other161) {
  maxMemory = other161.maxMemory;
  latencyMs = other161.latencyMs;
  timeoutMs = other161.timeoutMs;
  threads = other161.threads;
  durability = other161.durability;
  __isset = other161.__isset;
}
WriterOptions& WriterOptions::operator=(const WriterOptions& other162) {
  maxMemory = other162.maxMemory;
  latencyMs = other162.latencyMs;
  timeoutMs = other162.timeoutMs;
  threads = other162.threads;
  durability = other162.durability;
  __isset = other162.__isset;
  return *this;
}
void WriterOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriterOptions(";
  out << "maxMemory=" << to_string(maxMemory);
  out << ", " << "latencyMs=" << to_string(latencyMs);
  out << ", " << "timeoutMs=" << to_string(timeoutMs);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ")";
}


CompactionStrategyConfig::~CompactionStrategyConfig() throw() {
}


void CompactionStrategyConfig::__set_className(const std::string& val) {
  this->className = val;
}

void CompactionStrategyConfig::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
}

uint32_t CompactionStrategyConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _ktype164;
            ::apache::thrift::protocol::TType _vtype165;
            xfer += iprot->readMapBegin(_ktype164, _vtype165, _size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              std::string _key168;
              xfer += iprot->readString(_key168);
              std::string& _val169 = this->options[_key168];
              xfer += iprot->readString(_val169);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactionStrategyConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionStrategyConfig");

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::map<std::string, std::string> ::const_iterator _iter170;
    for (_iter170 = this->options.begin(); _iter170 != this->options.end(); ++_iter170)
    {
      xfer += oprot->writeString(_iter170->first);
      xfer += oprot->writeString(_iter170->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionStrategyConfig &a, CompactionStrategyConfig &b) {
  using ::std::swap;
  swap(a.className, b.className);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

CompactionStrategyConfig::CompactionStrategyConfig(const CompactionStrategyConfig& other171) {
  className = other171.className;
  options = other171.options;
  __isset = other171.__isset;
}
CompactionStrategyConfig& CompactionStrategyConfig::operator=(const CompactionStrategyConfig& other172) {
  className = other172.className;
  options = other172.options;
  __isset = other172.__isset;
  return *this;
}
void CompactionStrategyConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionStrategyConfig(";
  out << "className=" << to_string(className);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


UnknownScanner::~UnknownScanner() throw() {
}


void UnknownScanner::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t UnknownScanner::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownScanner::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownScanner");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownScanner &a, UnknownScanner &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

UnknownScanner::UnknownScanner(const UnknownScanner& other173) : TException() {
  msg = other173.msg;
  __isset = other173.__isset;
}
UnknownScanner& UnknownScanner::operator=(const UnknownScanner& other174) {
  msg = other174.msg;
  __isset = other174.__isset;
  return *this;
}
void UnknownScanner::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownScanner(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* UnknownScanner::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownScanner";
  }
}


UnknownWriter::~UnknownWriter() throw() {
}


void UnknownWriter::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t UnknownWriter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownWriter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownWriter");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownWriter &a, UnknownWriter &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

UnknownWriter::UnknownWriter(const UnknownWriter& other175) : TException() {
  msg = other175.msg;
  __isset = other175.__isset;
}
UnknownWriter& UnknownWriter::operator=(const UnknownWriter& other176) {
  msg = other176.msg;
  __isset = other176.__isset;
  return *this;
}
void UnknownWriter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownWriter(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* UnknownWriter::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownWriter";
  }
}


NoMoreEntriesException::~NoMoreEntriesException() throw() {
}


void NoMoreEntriesException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t NoMoreEntriesException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoMoreEntriesException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoMoreEntriesException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoMoreEntriesException &a, NoMoreEntriesException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

NoMoreEntriesException::NoMoreEntriesException(const NoMoreEntriesException& other177) : TException() {
  msg = other177.msg;
  __isset = other177.__isset;
}
NoMoreEntriesException& NoMoreEntriesException::operator=(const NoMoreEntriesException& other178) {
  msg = other178.msg;
  __isset = other178.__isset;
  return *this;
}
void NoMoreEntriesException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoMoreEntriesException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* NoMoreEntriesException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoMoreEntriesException";
  }
}


AccumuloException::~AccumuloException() throw() {
}


void AccumuloException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t AccumuloException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccumuloException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccumuloException &a, AccumuloException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

AccumuloException::AccumuloException(const AccumuloException& other179) : TException() {
  msg = other179.msg;
  __isset = other179.__isset;
}
AccumuloException& AccumuloException::operator=(const AccumuloException& other180) {
  msg = other180.msg;
  __isset = other180.__isset;
  return *this;
}
void AccumuloException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccumuloException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* AccumuloException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AccumuloException";
  }
}


AccumuloSecurityException::~AccumuloSecurityException() throw() {
}


void AccumuloSecurityException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t AccumuloSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccumuloSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccumuloSecurityException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccumuloSecurityException &a, AccumuloSecurityException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

AccumuloSecurityException::AccumuloSecurityException(const AccumuloSecurityException& other181) : TException() {
  msg = other181.msg;
  __isset = other181.__isset;
}
AccumuloSecurityException& AccumuloSecurityException::operator=(const AccumuloSecurityException& other182) {
  msg = other182.msg;
  __isset = other182.__isset;
  return *this;
}
void AccumuloSecurityException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccumuloSecurityException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* AccumuloSecurityException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AccumuloSecurityException";
  }
}


TableNotFoundException::~TableNotFoundException() throw() {
}


void TableNotFoundException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t TableNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableNotFoundException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableNotFoundException &a, TableNotFoundException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

TableNotFoundException::TableNotFoundException(const TableNotFoundException& other183) : TException() {
  msg = other183.msg;
  __isset = other183.__isset;
}
TableNotFoundException& TableNotFoundException::operator=(const TableNotFoundException& other184) {
  msg = other184.msg;
  __isset = other184.__isset;
  return *this;
}
void TableNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableNotFoundException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* TableNotFoundException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TableNotFoundException";
  }
}


TableExistsException::~TableExistsException() throw() {
}


void TableExistsException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t TableExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TableExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableExistsException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableExistsException &a, TableExistsException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

TableExistsException::TableExistsException(const TableExistsException& other185) : TException() {
  msg = other185.msg;
  __isset = other185.__isset;
}
TableExistsException& TableExistsException::operator=(const TableExistsException& other186) {
  msg = other186.msg;
  __isset = other186.__isset;
  return *this;
}
void TableExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableExistsException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* TableExistsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TableExistsException";
  }
}


MutationsRejectedException::~MutationsRejectedException() throw() {
}


void MutationsRejectedException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t MutationsRejectedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MutationsRejectedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MutationsRejectedException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MutationsRejectedException &a, MutationsRejectedException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

MutationsRejectedException::MutationsRejectedException(const MutationsRejectedException& other187) : TException() {
  msg = other187.msg;
  __isset = other187.__isset;
}
MutationsRejectedException& MutationsRejectedException::operator=(const MutationsRejectedException& other188) {
  msg = other188.msg;
  __isset = other188.__isset;
  return *this;
}
void MutationsRejectedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MutationsRejectedException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* MutationsRejectedException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MutationsRejectedException";
  }
}


NamespaceExistsException::~NamespaceExistsException() throw() {
}


void NamespaceExistsException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t NamespaceExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NamespaceExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NamespaceExistsException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NamespaceExistsException &a, NamespaceExistsException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

NamespaceExistsException::NamespaceExistsException(const NamespaceExistsException& other189) : TException() {
  msg = other189.msg;
  __isset = other189.__isset;
}
NamespaceExistsException& NamespaceExistsException::operator=(const NamespaceExistsException& other190) {
  msg = other190.msg;
  __isset = other190.__isset;
  return *this;
}
void NamespaceExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NamespaceExistsException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* NamespaceExistsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NamespaceExistsException";
  }
}


NamespaceNotFoundException::~NamespaceNotFoundException() throw() {
}


void NamespaceNotFoundException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t NamespaceNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NamespaceNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NamespaceNotFoundException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NamespaceNotFoundException &a, NamespaceNotFoundException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

NamespaceNotFoundException::NamespaceNotFoundException(const NamespaceNotFoundException& other191) : TException() {
  msg = other191.msg;
  __isset = other191.__isset;
}
NamespaceNotFoundException& NamespaceNotFoundException::operator=(const NamespaceNotFoundException& other192) {
  msg = other192.msg;
  __isset = other192.__isset;
  return *this;
}
void NamespaceNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NamespaceNotFoundException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* NamespaceNotFoundException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NamespaceNotFoundException";
  }
}


NamespaceNotEmptyException::~NamespaceNotEmptyException() throw() {
}


void NamespaceNotEmptyException::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t NamespaceNotEmptyException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NamespaceNotEmptyException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NamespaceNotEmptyException");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NamespaceNotEmptyException &a, NamespaceNotEmptyException &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

NamespaceNotEmptyException::NamespaceNotEmptyException(const NamespaceNotEmptyException& other193) : TException() {
  msg = other193.msg;
  __isset = other193.__isset;
}
NamespaceNotEmptyException& NamespaceNotEmptyException::operator=(const NamespaceNotEmptyException& other194) {
  msg = other194.msg;
  __isset = other194.__isset;
  return *this;
}
void NamespaceNotEmptyException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NamespaceNotEmptyException(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* NamespaceNotEmptyException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NamespaceNotEmptyException";
  }
}

} // namespace

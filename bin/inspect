#! /usr/bin/env python

from subprocess import Popen, PIPE
import sys, os, re

# Stacks containing this information are not really helpful
ignore = ('parking', 'GC Thread', 'TIMED_WAITING', 'CMS Threads', 'Finalizer',
	  'Reference Handler', 'VM Thread', 'Task Thread', 
	  'Low Memory Detector', 'CompilerThread', 'Signal Dispatcher', 
          'Surrogate Locker Thread', 'ServerSocketAdaptor.accept', 'Attach Listener',
          'ServerSocket.accept', 'Full thread dump Java HotSpot', 
	  'sun.nio.ch.SelectorImpl.select', 'DestroyJavaVM', 'GC task thread#')

def main():
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s [tserver|gc|master]\n" % sys.argv[0])
	sys.exit(1)
    # find the process
    pid, err = Popen('pgrep -f "java.*Main %s$"' % sys.argv[1], shell=True, stdout=PIPE).communicate()
    pids = map(int, pid.split())
    # make sure it is unique
    if len(pids) == 0:
        print "No %s found" % sys.argv[1]
        sys.exit(0)
    if len(pids) > 1:
        print "%d %s processes found" % (len(pids), sys.argv[1])
        sys.exit(0)
    pid = pids[0]
    
    # grab the stack
    trace = Popen('jstack %d' % pid, shell=True, stdout=PIPE)
    out, err = trace.communicate()
    stacks = out.split('\n', 1)
    if len(stacks) < 2:
        return

    # ignore the first line, and separate the threads
    stacks = stacks[1].split('\n"')
    counted = {}
    for stack in stacks:
	stack = '"' + stack
        skip = False
        for i in ignore:
            if stack.find(i) >= 0:
	        skip = True
                break
        if skip: continue

        # shorten thrift service thread waits to a single line
	if stack.find('readMessageBegin') >= 0 and \
            stack.find('Processor.process(') >= 0:
            match = re.search(r'\.([A-Za-z_]+)\$Processor.process', stack)
	    if match:
	        stack = match.group(1) + " Blocked Waiting for requests "

        # shorten http status service to one line
        if stack.find('org.mortbay.http.HttpRequest.readHeader') >= 0:
            stack = stack.split('\n')[0] + ' Servicing Web Requests'

        counted.setdefault(stack, 0)
        counted[stack] += 1
    for count, stack in sorted([(c, s) for s, c in counted.items()]):
        if count > 1:
            print "(%d)" % count, stack
        else:
            print stack


main()
